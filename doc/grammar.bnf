globalDecl ::= [accessFlag] {moduleMember};
moduleDecl ::= "Module" ID {[accessFlag] moduleMember} "End Module";
accessFlag ::= "Public"|"Private"|"Friend"|"Protected";
methodFlag ::= "Static"|"Virtual"|"Override";
moduleMember ::= functionDecl 
                | subDecl 
                | typeDecl 
                | enumDecl 
                | dimDecl
                | classDecl
                | moduleDecl
                | interfaceDecl
                | externalDecl
                | importDecl
                ;

classDecl ::= "Class" ID [extendPart] [implPart] { [accessFlag] classMember} "End Class";
extendPart ::= "Extend" annotation;
implPart ::= "Impl" annotation {"," annotation};
classMember ::= [methodFlag] (functionDecl | subDecl)
              | operatorDecl
              | constructorDecl
              | dimDecl
              ;

constructorDecl ::= "New" "(" [parameterList] ")" {statement} "End New";

operatorDecl ::= "Operator" ID "(" [parameterList] ")" "As" annotation {statement} "End Operator";

dimDecl ::= ["Dim"|"Const"] variableDecl {"," variableDecl};

typeDecl ::= "Type" ID {typeList} "End Type";
typeList ::= ID "As" annotation;

enumDecl ::= "Enum" ID {enumList} "End Enum";
enumList ::= ID ["=" Digit];

interfaceDecl ::= "Interface" ID {functionInterface|subInterface} "End Interface";
functionInterface ::= "Function" ID "(" [parameterList] ")" "As" annotation;
subInterface ::= "Sub" ID "(" [parameterList] ")";

externalDecl ::= "Declare" externalFunc | externalSub;
externalFunc ::= "Function" ["Lib" String] ["Alias" String] ID "(" [parameterList] ")" "As" annotation;
externalSub ::= "Sub" ID ["Lib" String] ["Alias" String] "(" [parameterList] ")"

importDecl ::= "Import" annotation;

parameterList ::= parameter {"," parameter};
parameter ::= ["Optional"|"ParamArray"] ["Byval"|"Byref"] ID "As" annotation ["=" expr];

functionDecl ::= functionInterface {statement} "End Function";
subDecl ::= subInterface {statement} "End Sub";

statement ::= forStmt
            | letStmt
            | loopStmt
            | ifStmt
            | selectStmt
            | controlStmt
            | exprStmt
            ;

forStmt ::= "For" expr "=" expr "To" expr ["Step" expr] {statement} "Next";

letStmt ::= "Let" variableDecl {"," variableDecl};
variableDecl ::= ID ["As" annotation] ["=" expr];

loopStmt ::= "While" expr {statement} "Wend";

ifStmt ::= "If" expr "Then" {statement} {elseIfPart} [elsePart] "End If";
elseIfPart ::= "ElseIf" expr "Then" {statement};
elsePart ::= "Else" {statement};

selectStmt ::= "Select" "Case" expr {caseList} "End Select";
caseList ::= "Case" expr {statement};

controlStmt ::= "Return" expr
              | "Continue"
              | "Exit" ("For"|"While"|"Sub")
              ;

exprStmt ::= expr;

expr ::= logicNot ("And"|"Or"|"Xor") expr;

logicNot ::= {"Not"} cmp;

cmp ::= add ("=="|"<>"|"<"|">"|"<="|"=<"|">=") cmp;

add ::= term ("+"|"-") add;

term ::= factor ("*"|"/"|"\\") term;

factor ::= unary (":" expr | "=" expr | "As" annotation {"As" annotation});

unary ::= ("-"|"+") unary
        | terminal "." unary
        | terminal
        ;

terminal ::= Digit 
           | Decimal 
           | String 
           | Char
           | "(" expr ")"
           | array
           | ID argsBody
           | "New" annotation "(" argsBody ")"
           ;

argsBody ::= ["(" [argList] ")"] ["[" expr "]"];
argList ::= argument {"," argument};
argument ::= ["Byval"|"Byref"] expr;

annotation ::= annotationUnit {"." annotationUnit} ["[]"];
annotationUnit ::= ID;


array ::= "[" expr ["," expr] "]";

Digit ::= {Number};
Decimal ::= Digit ["." Digit];
ID ::= {Letter};
String ::= '"' {Letter} '"'
Char ::= "'"(* ASCII Char *)"'";
Number ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ;
Letter ::= A-Z;

