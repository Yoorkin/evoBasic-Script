// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: backage.proto

#include "backage.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Backage {
PROTOBUF_CONSTEXPR Dependency::Dependency(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DependencyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DependencyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DependencyDefaultTypeInternal() {}
  union {
    Dependency _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DependencyDefaultTypeInternal _Dependency_default_instance_;
PROTOBUF_CONSTEXPR TextToken::TextToken(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TextTokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextTokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextTokenDefaultTypeInternal() {}
  union {
    TextToken _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextTokenDefaultTypeInternal _TextToken_default_instance_;
PROTOBUF_CONSTEXPR ConstructedToken::ConstructedToken(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tokens_)*/{}
  , /*decltype(_impl_._tokens_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConstructedTokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConstructedTokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConstructedTokenDefaultTypeInternal() {}
  union {
    ConstructedToken _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConstructedTokenDefaultTypeInternal _ConstructedToken_default_instance_;
PROTOBUF_CONSTEXPR ArrayToken::ArrayToken(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.typetoken_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ArrayTokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArrayTokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArrayTokenDefaultTypeInternal() {}
  union {
    ArrayToken _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArrayTokenDefaultTypeInternal _ArrayToken_default_instance_;
PROTOBUF_CONSTEXPR TokenDefinition::TokenDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.definition_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TokenDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenDefinitionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenDefinitionDefaultTypeInternal() {}
  union {
    TokenDefinition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenDefinitionDefaultTypeInternal _TokenDefinition_default_instance_;
PROTOBUF_CONSTEXPR Package::Package(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dependencies_)*/{}
  , /*decltype(_impl_.tokens_)*/{}
  , /*decltype(_impl_.declarations_)*/{}
  , /*decltype(_impl_.identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PackageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PackageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PackageDefaultTypeInternal() {}
  union {
    Package _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PackageDefaultTypeInternal _Package_default_instance_;
PROTOBUF_CONSTEXPR Declaration::Declaration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.Member_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct DeclarationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeclarationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeclarationDefaultTypeInternal() {}
  union {
    Declaration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeclarationDefaultTypeInternal _Declaration_default_instance_;
PROTOBUF_CONSTEXPR ClassDecl::ClassDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.impltoken_)*/{}
  , /*decltype(_impl_._impltoken_cached_byte_size_)*/{0}
  , /*decltype(_impl_.declarations_)*/{}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_.nametoken_)*/0u
  , /*decltype(_impl_.basetoken_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClassDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClassDeclDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClassDeclDefaultTypeInternal() {}
  union {
    ClassDecl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClassDeclDefaultTypeInternal _ClassDecl_default_instance_;
PROTOBUF_CONSTEXPR RecordDecl::RecordDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.declarations_)*/{}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_.nametoken_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecordDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecordDeclDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecordDeclDefaultTypeInternal() {}
  union {
    RecordDecl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecordDeclDefaultTypeInternal _RecordDecl_default_instance_;
PROTOBUF_CONSTEXPR EnumDecl::EnumDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.constants_)*/{}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_.nametoken_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EnumDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnumDeclDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnumDeclDefaultTypeInternal() {}
  union {
    EnumDecl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnumDeclDefaultTypeInternal _EnumDecl_default_instance_;
PROTOBUF_CONSTEXPR EnumConstant::EnumConstant(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nametoken_)*/0u
  , /*decltype(_impl_.value_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EnumConstantDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnumConstantDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnumConstantDefaultTypeInternal() {}
  union {
    EnumConstant _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnumConstantDefaultTypeInternal _EnumConstant_default_instance_;
PROTOBUF_CONSTEXPR VariableDecl::VariableDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.initial_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_.nametoken_)*/0u
  , /*decltype(_impl_.typetoken_)*/0u} {}
struct VariableDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VariableDeclDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VariableDeclDefaultTypeInternal() {}
  union {
    VariableDecl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VariableDeclDefaultTypeInternal _VariableDecl_default_instance_;
PROTOBUF_CONSTEXPR ParameterDecl::ParameterDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.initial_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_.nametoken_)*/0u
  , /*decltype(_impl_.typetoken_)*/0u} {}
struct ParameterDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParameterDeclDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParameterDeclDefaultTypeInternal() {}
  union {
    ParameterDecl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParameterDeclDefaultTypeInternal _ParameterDecl_default_instance_;
PROTOBUF_CONSTEXPR ModuleDecl::ModuleDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.declarations_)*/{}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_.nametoken_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleDeclDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleDeclDefaultTypeInternal() {}
  union {
    ModuleDecl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleDeclDefaultTypeInternal _ModuleDecl_default_instance_;
PROTOBUF_CONSTEXPR LocalIndex::LocalIndex(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.typetoken_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LocalIndexDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalIndexDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalIndexDefaultTypeInternal() {}
  union {
    LocalIndex _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalIndexDefaultTypeInternal _LocalIndex_default_instance_;
PROTOBUF_CONSTEXPR MethodDecl::MethodDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.params_)*/{}
  , /*decltype(_impl_.localindex_)*/{}
  , /*decltype(_impl_.linenumbers_)*/{}
  , /*decltype(_impl_.exceptionentry_)*/{}
  , /*decltype(_impl_.block_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_.nametoken_)*/0u
  , /*decltype(_impl_.rettypetoken_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MethodDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MethodDeclDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MethodDeclDefaultTypeInternal() {}
  union {
    MethodDecl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MethodDeclDefaultTypeInternal _MethodDecl_default_instance_;
PROTOBUF_CONSTEXPR CtorDecl::CtorDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.params_)*/{}
  , /*decltype(_impl_.localindex_)*/{}
  , /*decltype(_impl_.linenumbers_)*/{}
  , /*decltype(_impl_.exceptionentry_)*/{}
  , /*decltype(_impl_.block_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CtorDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CtorDeclDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CtorDeclDefaultTypeInternal() {}
  union {
    CtorDecl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CtorDeclDefaultTypeInternal _CtorDecl_default_instance_;
PROTOBUF_CONSTEXPR ForeignEntryDecl::ForeignEntryDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.params_)*/{}
  , /*decltype(_impl_.block_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lib_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.alias_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_.nametoken_)*/0u
  , /*decltype(_impl_.rettypetoken_)*/0u} {}
struct ForeignEntryDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ForeignEntryDeclDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ForeignEntryDeclDefaultTypeInternal() {}
  union {
    ForeignEntryDecl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ForeignEntryDeclDefaultTypeInternal _ForeignEntryDecl_default_instance_;
PROTOBUF_CONSTEXPR LineNumber::LineNumber(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.line_)*/0u
  , /*decltype(_impl_.offset_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LineNumberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LineNumberDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LineNumberDefaultTypeInternal() {}
  union {
    LineNumber _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LineNumberDefaultTypeInternal _LineNumber_default_instance_;
PROTOBUF_CONSTEXPR ExceptionEntry::ExceptionEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.offset_)*/0u
  , /*decltype(_impl_.length_)*/0u
  , /*decltype(_impl_.target_)*/0u
  , /*decltype(_impl_.typetoken_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExceptionEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExceptionEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExceptionEntryDefaultTypeInternal() {}
  union {
    ExceptionEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExceptionEntryDefaultTypeInternal _ExceptionEntry_default_instance_;
}  // namespace Backage
static ::_pb::Metadata file_level_metadata_backage_2eproto[20];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_backage_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_backage_2eproto = nullptr;

const uint32_t TableStruct_backage_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::Dependency, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::Dependency, _impl_.text_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::TextToken, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::TextToken, _impl_.text_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::ConstructedToken, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::ConstructedToken, _impl_.tokens_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::ArrayToken, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::ArrayToken, _impl_.typetoken_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::TokenDefinition, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Backage::TokenDefinition, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::TokenDefinition, _impl_.id_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Backage::TokenDefinition, _impl_.definition_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::Package, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::Package, _impl_.dependencies_),
  PROTOBUF_FIELD_OFFSET(::Backage::Package, _impl_.tokens_),
  PROTOBUF_FIELD_OFFSET(::Backage::Package, _impl_.declarations_),
  PROTOBUF_FIELD_OFFSET(::Backage::Package, _impl_.identity_),
  PROTOBUF_FIELD_OFFSET(::Backage::Package, _impl_.version_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::Declaration, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Backage::Declaration, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Backage::Declaration, _impl_.Member_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::ClassDecl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::ClassDecl, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::Backage::ClassDecl, _impl_.nametoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::ClassDecl, _impl_.basetoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::ClassDecl, _impl_.impltoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::ClassDecl, _impl_.declarations_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::RecordDecl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::RecordDecl, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::Backage::RecordDecl, _impl_.nametoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::RecordDecl, _impl_.declarations_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::EnumDecl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::EnumDecl, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::Backage::EnumDecl, _impl_.nametoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::EnumDecl, _impl_.constants_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::EnumConstant, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::EnumConstant, _impl_.nametoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::EnumConstant, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::Backage::VariableDecl, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Backage::VariableDecl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::VariableDecl, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::Backage::VariableDecl, _impl_.nametoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::VariableDecl, _impl_.typetoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::VariableDecl, _impl_.initial_),
  ~0u,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::Backage::ParameterDecl, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Backage::ParameterDecl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::ParameterDecl, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::Backage::ParameterDecl, _impl_.nametoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::ParameterDecl, _impl_.typetoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::ParameterDecl, _impl_.initial_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::ModuleDecl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::ModuleDecl, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::Backage::ModuleDecl, _impl_.nametoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::ModuleDecl, _impl_.declarations_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::LocalIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::LocalIndex, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Backage::LocalIndex, _impl_.typetoken_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::MethodDecl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::MethodDecl, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::Backage::MethodDecl, _impl_.nametoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::MethodDecl, _impl_.params_),
  PROTOBUF_FIELD_OFFSET(::Backage::MethodDecl, _impl_.rettypetoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::MethodDecl, _impl_.localindex_),
  PROTOBUF_FIELD_OFFSET(::Backage::MethodDecl, _impl_.block_),
  PROTOBUF_FIELD_OFFSET(::Backage::MethodDecl, _impl_.linenumbers_),
  PROTOBUF_FIELD_OFFSET(::Backage::MethodDecl, _impl_.exceptionentry_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::CtorDecl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::CtorDecl, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::Backage::CtorDecl, _impl_.params_),
  PROTOBUF_FIELD_OFFSET(::Backage::CtorDecl, _impl_.localindex_),
  PROTOBUF_FIELD_OFFSET(::Backage::CtorDecl, _impl_.block_),
  PROTOBUF_FIELD_OFFSET(::Backage::CtorDecl, _impl_.linenumbers_),
  PROTOBUF_FIELD_OFFSET(::Backage::CtorDecl, _impl_.exceptionentry_),
  PROTOBUF_FIELD_OFFSET(::Backage::ForeignEntryDecl, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Backage::ForeignEntryDecl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::ForeignEntryDecl, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::Backage::ForeignEntryDecl, _impl_.nametoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::ForeignEntryDecl, _impl_.params_),
  PROTOBUF_FIELD_OFFSET(::Backage::ForeignEntryDecl, _impl_.rettypetoken_),
  PROTOBUF_FIELD_OFFSET(::Backage::ForeignEntryDecl, _impl_.block_),
  PROTOBUF_FIELD_OFFSET(::Backage::ForeignEntryDecl, _impl_.lib_),
  PROTOBUF_FIELD_OFFSET(::Backage::ForeignEntryDecl, _impl_.alias_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::LineNumber, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::LineNumber, _impl_.line_),
  PROTOBUF_FIELD_OFFSET(::Backage::LineNumber, _impl_.offset_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Backage::ExceptionEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Backage::ExceptionEntry, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::Backage::ExceptionEntry, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::Backage::ExceptionEntry, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::Backage::ExceptionEntry, _impl_.typetoken_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Backage::Dependency)},
  { 7, -1, -1, sizeof(::Backage::TextToken)},
  { 14, -1, -1, sizeof(::Backage::ConstructedToken)},
  { 21, -1, -1, sizeof(::Backage::ArrayToken)},
  { 28, -1, -1, sizeof(::Backage::TokenDefinition)},
  { 39, -1, -1, sizeof(::Backage::Package)},
  { 50, -1, -1, sizeof(::Backage::Declaration)},
  { 66, -1, -1, sizeof(::Backage::ClassDecl)},
  { 77, -1, -1, sizeof(::Backage::RecordDecl)},
  { 86, -1, -1, sizeof(::Backage::EnumDecl)},
  { 95, -1, -1, sizeof(::Backage::EnumConstant)},
  { 103, 113, -1, sizeof(::Backage::VariableDecl)},
  { 117, 127, -1, sizeof(::Backage::ParameterDecl)},
  { 131, -1, -1, sizeof(::Backage::ModuleDecl)},
  { 140, -1, -1, sizeof(::Backage::LocalIndex)},
  { 148, -1, -1, sizeof(::Backage::MethodDecl)},
  { 162, -1, -1, sizeof(::Backage::CtorDecl)},
  { 174, 187, -1, sizeof(::Backage::ForeignEntryDecl)},
  { 194, -1, -1, sizeof(::Backage::LineNumber)},
  { 202, -1, -1, sizeof(::Backage::ExceptionEntry)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Backage::_Dependency_default_instance_._instance,
  &::Backage::_TextToken_default_instance_._instance,
  &::Backage::_ConstructedToken_default_instance_._instance,
  &::Backage::_ArrayToken_default_instance_._instance,
  &::Backage::_TokenDefinition_default_instance_._instance,
  &::Backage::_Package_default_instance_._instance,
  &::Backage::_Declaration_default_instance_._instance,
  &::Backage::_ClassDecl_default_instance_._instance,
  &::Backage::_RecordDecl_default_instance_._instance,
  &::Backage::_EnumDecl_default_instance_._instance,
  &::Backage::_EnumConstant_default_instance_._instance,
  &::Backage::_VariableDecl_default_instance_._instance,
  &::Backage::_ParameterDecl_default_instance_._instance,
  &::Backage::_ModuleDecl_default_instance_._instance,
  &::Backage::_LocalIndex_default_instance_._instance,
  &::Backage::_MethodDecl_default_instance_._instance,
  &::Backage::_CtorDecl_default_instance_._instance,
  &::Backage::_ForeignEntryDecl_default_instance_._instance,
  &::Backage::_LineNumber_default_instance_._instance,
  &::Backage::_ExceptionEntry_default_instance_._instance,
};

const char descriptor_table_protodef_backage_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rbackage.proto\022\007Backage\"\032\n\nDependency\022\014"
  "\n\004text\030\001 \001(\t\"\031\n\tTextToken\022\014\n\004text\030\001 \001(\t\""
  "\"\n\020ConstructedToken\022\016\n\006tokens\030\001 \003(\r\"\037\n\nA"
  "rrayToken\022\021\n\ttypeToken\030\001 \001(\r\"\266\001\n\017TokenDe"
  "finition\022\n\n\002id\030\001 \001(\r\022\'\n\ttextToken\030\002 \001(\0132"
  "\022.Backage.TextTokenH\000\0225\n\020constructedToke"
  "n\030\003 \001(\0132\031.Backage.ConstructedTokenH\000\022)\n\n"
  "arrayToken\030\004 \001(\0132\023.Backage.ArrayTokenH\000B"
  "\014\n\ndefinition\"\255\001\n\007Package\022)\n\014dependencie"
  "s\030\001 \003(\0132\023.Backage.Dependency\022(\n\006tokens\030\002"
  " \003(\0132\030.Backage.TokenDefinition\022*\n\014declar"
  "ations\030\003 \003(\0132\024.Backage.Declaration\022\020\n\010id"
  "entity\030\004 \001(\t\022\017\n\007version\030\005 \001(\004\"\244\003\n\013Declar"
  "ation\022\'\n\tclassDecl\030\001 \001(\0132\022.Backage.Class"
  "DeclH\000\022)\n\nrecordDecl\030\002 \001(\0132\023.Backage.Rec"
  "ordDeclH\000\022%\n\010enumDecl\030\003 \001(\0132\021.Backage.En"
  "umDeclH\000\022-\n\014enumConstant\030\004 \001(\0132\025.Backage"
  ".EnumConstantH\000\022-\n\014varaibleDecl\030\005 \001(\0132\025."
  "Backage.VariableDeclH\000\022)\n\nmoduleDecl\030\006 \001"
  "(\0132\023.Backage.ModuleDeclH\000\022)\n\nmethodDecl\030"
  "\007 \001(\0132\023.Backage.MethodDeclH\000\022%\n\010ctorDecl"
  "\030\010 \001(\0132\021.Backage.CtorDeclH\000\0225\n\020foreignEn"
  "tryDecl\030\t \001(\0132\031.Backage.ForeignEntryDecl"
  "H\000B\010\n\006Member\"~\n\tClassDecl\022\014\n\004flag\030\001 \001(\r\022"
  "\021\n\tnameToken\030\002 \001(\r\022\021\n\tbaseToken\030\003 \001(\r\022\021\n"
  "\timplToken\030\004 \003(\r\022*\n\014declarations\030\005 \003(\0132\024"
  ".Backage.Declaration\"Y\n\nRecordDecl\022\014\n\004fl"
  "ag\030\001 \001(\r\022\021\n\tnameToken\030\002 \001(\r\022*\n\014declarati"
  "ons\030\003 \003(\0132\024.Backage.Declaration\"U\n\010EnumD"
  "ecl\022\014\n\004flag\030\001 \001(\r\022\021\n\tnameToken\030\002 \001(\r\022(\n\t"
  "constants\030\003 \003(\0132\025.Backage.EnumConstant\"0"
  "\n\014EnumConstant\022\021\n\tnameToken\030\001 \001(\r\022\r\n\005val"
  "ue\030\002 \001(\r\"d\n\014VariableDecl\022\014\n\004flag\030\001 \001(\r\022\021"
  "\n\tnameToken\030\002 \001(\r\022\021\n\ttypeToken\030\003 \001(\r\022\024\n\007"
  "initial\030\004 \001(\014H\000\210\001\001B\n\n\010_initial\"e\n\rParame"
  "terDecl\022\014\n\004flag\030\001 \001(\r\022\021\n\tnameToken\030\002 \001(\r"
  "\022\021\n\ttypeToken\030\003 \001(\r\022\024\n\007initial\030\004 \001(\014H\000\210\001"
  "\001B\n\n\010_initial\"Y\n\nModuleDecl\022\014\n\004flag\030\001 \001("
  "\r\022\021\n\tnameToken\030\002 \001(\r\022*\n\014declarations\030\003 \003"
  "(\0132\024.Backage.Declaration\"+\n\nLocalIndex\022\n"
  "\n\002id\030\001 \001(\r\022\021\n\ttypeToken\030\002 \001(\r\"\376\001\n\nMethod"
  "Decl\022\014\n\004flag\030\001 \001(\r\022\021\n\tnameToken\030\002 \001(\r\022&\n"
  "\006params\030\003 \003(\0132\026.Backage.ParameterDecl\022\024\n"
  "\014retTypeToken\030\004 \001(\r\022\'\n\nlocalIndex\030\005 \003(\0132"
  "\023.Backage.LocalIndex\022\r\n\005block\030\006 \001(\014\022(\n\013l"
  "ineNumbers\030\007 \003(\0132\023.Backage.LineNumber\022/\n"
  "\016exceptionEntry\030\010 \003(\0132\027.Backage.Exceptio"
  "nEntry\"\323\001\n\010CtorDecl\022\014\n\004flag\030\001 \001(\r\022&\n\006par"
  "ams\030\002 \003(\0132\026.Backage.ParameterDecl\022\'\n\nloc"
  "alIndex\030\003 \003(\0132\023.Backage.LocalIndex\022\r\n\005bl"
  "ock\030\004 \001(\014\022(\n\013lineNumbers\030\005 \003(\0132\023.Backage"
  ".LineNumber\022/\n\016exceptionEntry\030\006 \003(\0132\027.Ba"
  "ckage.ExceptionEntry\"\270\001\n\020ForeignEntryDec"
  "l\022\014\n\004flag\030\001 \001(\r\022\021\n\tnameToken\030\002 \001(\r\022&\n\006pa"
  "rams\030\003 \003(\0132\026.Backage.ParameterDecl\022\024\n\014re"
  "tTypeToken\030\004 \001(\r\022\r\n\005block\030\005 \001(\014\022\020\n\003lib\030\006"
  " \001(\014H\000\210\001\001\022\022\n\005alias\030\007 \001(\014H\001\210\001\001B\006\n\004_libB\010\n"
  "\006_alias\"*\n\nLineNumber\022\014\n\004line\030\001 \001(\r\022\016\n\006o"
  "ffset\030\002 \001(\r\"S\n\016ExceptionEntry\022\016\n\006offset\030"
  "\001 \001(\r\022\016\n\006length\030\002 \001(\r\022\016\n\006target\030\003 \001(\r\022\021\n"
  "\ttypeToken\030\004 \001(\rb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_backage_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_backage_2eproto = {
    false, false, 2424, descriptor_table_protodef_backage_2eproto,
    "backage.proto",
    &descriptor_table_backage_2eproto_once, nullptr, 0, 20,
    schemas, file_default_instances, TableStruct_backage_2eproto::offsets,
    file_level_metadata_backage_2eproto, file_level_enum_descriptors_backage_2eproto,
    file_level_service_descriptors_backage_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_backage_2eproto_getter() {
  return &descriptor_table_backage_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_backage_2eproto(&descriptor_table_backage_2eproto);
namespace Backage {

// ===================================================================

class Dependency::_Internal {
 public:
};

Dependency::Dependency(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.Dependency)
}
Dependency::Dependency(const Dependency& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Dependency* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Backage.Dependency)
}

inline void Dependency::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Dependency::~Dependency() {
  // @@protoc_insertion_point(destructor:Backage.Dependency)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Dependency::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void Dependency::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Dependency::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.Dependency)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.text_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Dependency::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Backage.Dependency.text"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Dependency::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.Dependency)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Backage.Dependency.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.Dependency)
  return target;
}

size_t Dependency::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.Dependency)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Dependency::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Dependency::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Dependency::GetClassData() const { return &_class_data_; }


void Dependency::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Dependency*>(&to_msg);
  auto& from = static_cast<const Dependency&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.Dependency)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Dependency::CopyFrom(const Dependency& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.Dependency)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dependency::IsInitialized() const {
  return true;
}

void Dependency::InternalSwap(Dependency* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Dependency::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[0]);
}

// ===================================================================

class TextToken::_Internal {
 public:
};

TextToken::TextToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.TextToken)
}
TextToken::TextToken(const TextToken& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TextToken* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Backage.TextToken)
}

inline void TextToken::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TextToken::~TextToken() {
  // @@protoc_insertion_point(destructor:Backage.TextToken)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextToken::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void TextToken::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TextToken::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.TextToken)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.text_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TextToken::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Backage.TextToken.text"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextToken::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.TextToken)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Backage.TextToken.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.TextToken)
  return target;
}

size_t TextToken::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.TextToken)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TextToken::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TextToken::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TextToken::GetClassData() const { return &_class_data_; }


void TextToken::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TextToken*>(&to_msg);
  auto& from = static_cast<const TextToken&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.TextToken)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TextToken::CopyFrom(const TextToken& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.TextToken)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextToken::IsInitialized() const {
  return true;
}

void TextToken::InternalSwap(TextToken* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TextToken::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[1]);
}

// ===================================================================

class ConstructedToken::_Internal {
 public:
};

ConstructedToken::ConstructedToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.ConstructedToken)
}
ConstructedToken::ConstructedToken(const ConstructedToken& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConstructedToken* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tokens_){from._impl_.tokens_}
    , /*decltype(_impl_._tokens_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Backage.ConstructedToken)
}

inline void ConstructedToken::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tokens_){arena}
    , /*decltype(_impl_._tokens_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConstructedToken::~ConstructedToken() {
  // @@protoc_insertion_point(destructor:Backage.ConstructedToken)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConstructedToken::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tokens_.~RepeatedField();
}

void ConstructedToken::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConstructedToken::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.ConstructedToken)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tokens_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConstructedToken::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 tokens = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_tokens(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_tokens(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConstructedToken::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.ConstructedToken)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 tokens = 1;
  {
    int byte_size = _impl_._tokens_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_tokens(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.ConstructedToken)
  return target;
}

size_t ConstructedToken::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.ConstructedToken)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 tokens = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.tokens_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._tokens_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConstructedToken::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConstructedToken::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConstructedToken::GetClassData() const { return &_class_data_; }


void ConstructedToken::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConstructedToken*>(&to_msg);
  auto& from = static_cast<const ConstructedToken&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.ConstructedToken)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tokens_.MergeFrom(from._impl_.tokens_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConstructedToken::CopyFrom(const ConstructedToken& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.ConstructedToken)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConstructedToken::IsInitialized() const {
  return true;
}

void ConstructedToken::InternalSwap(ConstructedToken* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConstructedToken::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[2]);
}

// ===================================================================

class ArrayToken::_Internal {
 public:
};

ArrayToken::ArrayToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.ArrayToken)
}
ArrayToken::ArrayToken(const ArrayToken& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ArrayToken* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.typetoken_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.typetoken_ = from._impl_.typetoken_;
  // @@protoc_insertion_point(copy_constructor:Backage.ArrayToken)
}

inline void ArrayToken::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.typetoken_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ArrayToken::~ArrayToken() {
  // @@protoc_insertion_point(destructor:Backage.ArrayToken)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArrayToken::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArrayToken::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ArrayToken::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.ArrayToken)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.typetoken_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArrayToken::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 typeToken = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.typetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArrayToken::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.ArrayToken)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 typeToken = 1;
  if (this->_internal_typetoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_typetoken(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.ArrayToken)
  return target;
}

size_t ArrayToken::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.ArrayToken)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 typeToken = 1;
  if (this->_internal_typetoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_typetoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArrayToken::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ArrayToken::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArrayToken::GetClassData() const { return &_class_data_; }


void ArrayToken::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ArrayToken*>(&to_msg);
  auto& from = static_cast<const ArrayToken&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.ArrayToken)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_typetoken() != 0) {
    _this->_internal_set_typetoken(from._internal_typetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArrayToken::CopyFrom(const ArrayToken& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.ArrayToken)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayToken::IsInitialized() const {
  return true;
}

void ArrayToken::InternalSwap(ArrayToken* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.typetoken_, other->_impl_.typetoken_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArrayToken::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[3]);
}

// ===================================================================

class TokenDefinition::_Internal {
 public:
  static const ::Backage::TextToken& texttoken(const TokenDefinition* msg);
  static const ::Backage::ConstructedToken& constructedtoken(const TokenDefinition* msg);
  static const ::Backage::ArrayToken& arraytoken(const TokenDefinition* msg);
};

const ::Backage::TextToken&
TokenDefinition::_Internal::texttoken(const TokenDefinition* msg) {
  return *msg->_impl_.definition_.texttoken_;
}
const ::Backage::ConstructedToken&
TokenDefinition::_Internal::constructedtoken(const TokenDefinition* msg) {
  return *msg->_impl_.definition_.constructedtoken_;
}
const ::Backage::ArrayToken&
TokenDefinition::_Internal::arraytoken(const TokenDefinition* msg) {
  return *msg->_impl_.definition_.arraytoken_;
}
void TokenDefinition::set_allocated_texttoken(::Backage::TextToken* texttoken) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_definition();
  if (texttoken) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(texttoken);
    if (message_arena != submessage_arena) {
      texttoken = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, texttoken, submessage_arena);
    }
    set_has_texttoken();
    _impl_.definition_.texttoken_ = texttoken;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.TokenDefinition.textToken)
}
void TokenDefinition::set_allocated_constructedtoken(::Backage::ConstructedToken* constructedtoken) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_definition();
  if (constructedtoken) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(constructedtoken);
    if (message_arena != submessage_arena) {
      constructedtoken = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constructedtoken, submessage_arena);
    }
    set_has_constructedtoken();
    _impl_.definition_.constructedtoken_ = constructedtoken;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.TokenDefinition.constructedToken)
}
void TokenDefinition::set_allocated_arraytoken(::Backage::ArrayToken* arraytoken) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_definition();
  if (arraytoken) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arraytoken);
    if (message_arena != submessage_arena) {
      arraytoken = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arraytoken, submessage_arena);
    }
    set_has_arraytoken();
    _impl_.definition_.arraytoken_ = arraytoken;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.TokenDefinition.arrayToken)
}
TokenDefinition::TokenDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.TokenDefinition)
}
TokenDefinition::TokenDefinition(const TokenDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.definition_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  clear_has_definition();
  switch (from.definition_case()) {
    case kTextToken: {
      _this->_internal_mutable_texttoken()->::Backage::TextToken::MergeFrom(
          from._internal_texttoken());
      break;
    }
    case kConstructedToken: {
      _this->_internal_mutable_constructedtoken()->::Backage::ConstructedToken::MergeFrom(
          from._internal_constructedtoken());
      break;
    }
    case kArrayToken: {
      _this->_internal_mutable_arraytoken()->::Backage::ArrayToken::MergeFrom(
          from._internal_arraytoken());
      break;
    }
    case DEFINITION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Backage.TokenDefinition)
}

inline void TokenDefinition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){0u}
    , decltype(_impl_.definition_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_definition();
}

TokenDefinition::~TokenDefinition() {
  // @@protoc_insertion_point(destructor:Backage.TokenDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenDefinition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_definition()) {
    clear_definition();
  }
}

void TokenDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenDefinition::clear_definition() {
// @@protoc_insertion_point(one_of_clear_start:Backage.TokenDefinition)
  switch (definition_case()) {
    case kTextToken: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.definition_.texttoken_;
      }
      break;
    }
    case kConstructedToken: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.definition_.constructedtoken_;
      }
      break;
    }
    case kArrayToken: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.definition_.arraytoken_;
      }
      break;
    }
    case DEFINITION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DEFINITION_NOT_SET;
}


void TokenDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.TokenDefinition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0u;
  clear_definition();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.TextToken textToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_texttoken(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.ConstructedToken constructedToken = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_constructedtoken(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.ArrayToken arrayToken = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_arraytoken(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenDefinition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.TokenDefinition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // .Backage.TextToken textToken = 2;
  if (_internal_has_texttoken()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::texttoken(this),
        _Internal::texttoken(this).GetCachedSize(), target, stream);
  }

  // .Backage.ConstructedToken constructedToken = 3;
  if (_internal_has_constructedtoken()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::constructedtoken(this),
        _Internal::constructedtoken(this).GetCachedSize(), target, stream);
  }

  // .Backage.ArrayToken arrayToken = 4;
  if (_internal_has_arraytoken()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::arraytoken(this),
        _Internal::arraytoken(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.TokenDefinition)
  return target;
}

size_t TokenDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.TokenDefinition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  switch (definition_case()) {
    // .Backage.TextToken textToken = 2;
    case kTextToken: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.definition_.texttoken_);
      break;
    }
    // .Backage.ConstructedToken constructedToken = 3;
    case kConstructedToken: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.definition_.constructedtoken_);
      break;
    }
    // .Backage.ArrayToken arrayToken = 4;
    case kArrayToken: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.definition_.arraytoken_);
      break;
    }
    case DEFINITION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenDefinition::GetClassData() const { return &_class_data_; }


void TokenDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenDefinition*>(&to_msg);
  auto& from = static_cast<const TokenDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.TokenDefinition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  switch (from.definition_case()) {
    case kTextToken: {
      _this->_internal_mutable_texttoken()->::Backage::TextToken::MergeFrom(
          from._internal_texttoken());
      break;
    }
    case kConstructedToken: {
      _this->_internal_mutable_constructedtoken()->::Backage::ConstructedToken::MergeFrom(
          from._internal_constructedtoken());
      break;
    }
    case kArrayToken: {
      _this->_internal_mutable_arraytoken()->::Backage::ArrayToken::MergeFrom(
          from._internal_arraytoken());
      break;
    }
    case DEFINITION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenDefinition::CopyFrom(const TokenDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.TokenDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenDefinition::IsInitialized() const {
  return true;
}

void TokenDefinition::InternalSwap(TokenDefinition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.id_, other->_impl_.id_);
  swap(_impl_.definition_, other->_impl_.definition_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[4]);
}

// ===================================================================

class Package::_Internal {
 public:
};

Package::Package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.Package)
}
Package::Package(const Package& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Package* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dependencies_){from._impl_.dependencies_}
    , decltype(_impl_.tokens_){from._impl_.tokens_}
    , decltype(_impl_.declarations_){from._impl_.declarations_}
    , decltype(_impl_.identity_){}
    , decltype(_impl_.version_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_identity().empty()) {
    _this->_impl_.identity_.Set(from._internal_identity(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:Backage.Package)
}

inline void Package::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dependencies_){arena}
    , decltype(_impl_.tokens_){arena}
    , decltype(_impl_.declarations_){arena}
    , decltype(_impl_.identity_){}
    , decltype(_impl_.version_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Package::~Package() {
  // @@protoc_insertion_point(destructor:Backage.Package)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Package::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dependencies_.~RepeatedPtrField();
  _impl_.tokens_.~RepeatedPtrField();
  _impl_.declarations_.~RepeatedPtrField();
  _impl_.identity_.Destroy();
}

void Package::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Package::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.Package)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dependencies_.Clear();
  _impl_.tokens_.Clear();
  _impl_.declarations_.Clear();
  _impl_.identity_.ClearToEmpty();
  _impl_.version_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Package::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Backage.Dependency dependencies = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dependencies(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.TokenDefinition tokens = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.Declaration declarations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_declarations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string identity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Backage.Package.identity"));
        } else
          goto handle_unusual;
        continue;
      // uint64 version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Package::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.Package)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Backage.Dependency dependencies = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dependencies_size()); i < n; i++) {
    const auto& repfield = this->_internal_dependencies(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Backage.TokenDefinition tokens = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tokens_size()); i < n; i++) {
    const auto& repfield = this->_internal_tokens(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Backage.Declaration declarations = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_declarations_size()); i < n; i++) {
    const auto& repfield = this->_internal_declarations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string identity = 4;
  if (!this->_internal_identity().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_identity().data(), static_cast<int>(this->_internal_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Backage.Package.identity");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_identity(), target);
  }

  // uint64 version = 5;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.Package)
  return target;
}

size_t Package::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.Package)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Backage.Dependency dependencies = 1;
  total_size += 1UL * this->_internal_dependencies_size();
  for (const auto& msg : this->_impl_.dependencies_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Backage.TokenDefinition tokens = 2;
  total_size += 1UL * this->_internal_tokens_size();
  for (const auto& msg : this->_impl_.tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Backage.Declaration declarations = 3;
  total_size += 1UL * this->_internal_declarations_size();
  for (const auto& msg : this->_impl_.declarations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string identity = 4;
  if (!this->_internal_identity().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_identity());
  }

  // uint64 version = 5;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Package::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Package::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Package::GetClassData() const { return &_class_data_; }


void Package::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Package*>(&to_msg);
  auto& from = static_cast<const Package&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.Package)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dependencies_.MergeFrom(from._impl_.dependencies_);
  _this->_impl_.tokens_.MergeFrom(from._impl_.tokens_);
  _this->_impl_.declarations_.MergeFrom(from._impl_.declarations_);
  if (!from._internal_identity().empty()) {
    _this->_internal_set_identity(from._internal_identity());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Package::CopyFrom(const Package& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.Package)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Package::IsInitialized() const {
  return true;
}

void Package::InternalSwap(Package* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dependencies_.InternalSwap(&other->_impl_.dependencies_);
  _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
  _impl_.declarations_.InternalSwap(&other->_impl_.declarations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.identity_, lhs_arena,
      &other->_impl_.identity_, rhs_arena
  );
  swap(_impl_.version_, other->_impl_.version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Package::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[5]);
}

// ===================================================================

class Declaration::_Internal {
 public:
  static const ::Backage::ClassDecl& classdecl(const Declaration* msg);
  static const ::Backage::RecordDecl& recorddecl(const Declaration* msg);
  static const ::Backage::EnumDecl& enumdecl(const Declaration* msg);
  static const ::Backage::EnumConstant& enumconstant(const Declaration* msg);
  static const ::Backage::VariableDecl& varaibledecl(const Declaration* msg);
  static const ::Backage::ModuleDecl& moduledecl(const Declaration* msg);
  static const ::Backage::MethodDecl& methoddecl(const Declaration* msg);
  static const ::Backage::CtorDecl& ctordecl(const Declaration* msg);
  static const ::Backage::ForeignEntryDecl& foreignentrydecl(const Declaration* msg);
};

const ::Backage::ClassDecl&
Declaration::_Internal::classdecl(const Declaration* msg) {
  return *msg->_impl_.Member_.classdecl_;
}
const ::Backage::RecordDecl&
Declaration::_Internal::recorddecl(const Declaration* msg) {
  return *msg->_impl_.Member_.recorddecl_;
}
const ::Backage::EnumDecl&
Declaration::_Internal::enumdecl(const Declaration* msg) {
  return *msg->_impl_.Member_.enumdecl_;
}
const ::Backage::EnumConstant&
Declaration::_Internal::enumconstant(const Declaration* msg) {
  return *msg->_impl_.Member_.enumconstant_;
}
const ::Backage::VariableDecl&
Declaration::_Internal::varaibledecl(const Declaration* msg) {
  return *msg->_impl_.Member_.varaibledecl_;
}
const ::Backage::ModuleDecl&
Declaration::_Internal::moduledecl(const Declaration* msg) {
  return *msg->_impl_.Member_.moduledecl_;
}
const ::Backage::MethodDecl&
Declaration::_Internal::methoddecl(const Declaration* msg) {
  return *msg->_impl_.Member_.methoddecl_;
}
const ::Backage::CtorDecl&
Declaration::_Internal::ctordecl(const Declaration* msg) {
  return *msg->_impl_.Member_.ctordecl_;
}
const ::Backage::ForeignEntryDecl&
Declaration::_Internal::foreignentrydecl(const Declaration* msg) {
  return *msg->_impl_.Member_.foreignentrydecl_;
}
void Declaration::set_allocated_classdecl(::Backage::ClassDecl* classdecl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Member();
  if (classdecl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(classdecl);
    if (message_arena != submessage_arena) {
      classdecl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classdecl, submessage_arena);
    }
    set_has_classdecl();
    _impl_.Member_.classdecl_ = classdecl;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.Declaration.classDecl)
}
void Declaration::set_allocated_recorddecl(::Backage::RecordDecl* recorddecl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Member();
  if (recorddecl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recorddecl);
    if (message_arena != submessage_arena) {
      recorddecl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recorddecl, submessage_arena);
    }
    set_has_recorddecl();
    _impl_.Member_.recorddecl_ = recorddecl;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.Declaration.recordDecl)
}
void Declaration::set_allocated_enumdecl(::Backage::EnumDecl* enumdecl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Member();
  if (enumdecl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(enumdecl);
    if (message_arena != submessage_arena) {
      enumdecl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enumdecl, submessage_arena);
    }
    set_has_enumdecl();
    _impl_.Member_.enumdecl_ = enumdecl;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.Declaration.enumDecl)
}
void Declaration::set_allocated_enumconstant(::Backage::EnumConstant* enumconstant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Member();
  if (enumconstant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(enumconstant);
    if (message_arena != submessage_arena) {
      enumconstant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enumconstant, submessage_arena);
    }
    set_has_enumconstant();
    _impl_.Member_.enumconstant_ = enumconstant;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.Declaration.enumConstant)
}
void Declaration::set_allocated_varaibledecl(::Backage::VariableDecl* varaibledecl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Member();
  if (varaibledecl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(varaibledecl);
    if (message_arena != submessage_arena) {
      varaibledecl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varaibledecl, submessage_arena);
    }
    set_has_varaibledecl();
    _impl_.Member_.varaibledecl_ = varaibledecl;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.Declaration.varaibleDecl)
}
void Declaration::set_allocated_moduledecl(::Backage::ModuleDecl* moduledecl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Member();
  if (moduledecl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(moduledecl);
    if (message_arena != submessage_arena) {
      moduledecl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moduledecl, submessage_arena);
    }
    set_has_moduledecl();
    _impl_.Member_.moduledecl_ = moduledecl;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.Declaration.moduleDecl)
}
void Declaration::set_allocated_methoddecl(::Backage::MethodDecl* methoddecl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Member();
  if (methoddecl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(methoddecl);
    if (message_arena != submessage_arena) {
      methoddecl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, methoddecl, submessage_arena);
    }
    set_has_methoddecl();
    _impl_.Member_.methoddecl_ = methoddecl;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.Declaration.methodDecl)
}
void Declaration::set_allocated_ctordecl(::Backage::CtorDecl* ctordecl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Member();
  if (ctordecl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ctordecl);
    if (message_arena != submessage_arena) {
      ctordecl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ctordecl, submessage_arena);
    }
    set_has_ctordecl();
    _impl_.Member_.ctordecl_ = ctordecl;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.Declaration.ctorDecl)
}
void Declaration::set_allocated_foreignentrydecl(::Backage::ForeignEntryDecl* foreignentrydecl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Member();
  if (foreignentrydecl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(foreignentrydecl);
    if (message_arena != submessage_arena) {
      foreignentrydecl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foreignentrydecl, submessage_arena);
    }
    set_has_foreignentrydecl();
    _impl_.Member_.foreignentrydecl_ = foreignentrydecl;
  }
  // @@protoc_insertion_point(field_set_allocated:Backage.Declaration.foreignEntryDecl)
}
Declaration::Declaration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.Declaration)
}
Declaration::Declaration(const Declaration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Declaration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.Member_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_Member();
  switch (from.Member_case()) {
    case kClassDecl: {
      _this->_internal_mutable_classdecl()->::Backage::ClassDecl::MergeFrom(
          from._internal_classdecl());
      break;
    }
    case kRecordDecl: {
      _this->_internal_mutable_recorddecl()->::Backage::RecordDecl::MergeFrom(
          from._internal_recorddecl());
      break;
    }
    case kEnumDecl: {
      _this->_internal_mutable_enumdecl()->::Backage::EnumDecl::MergeFrom(
          from._internal_enumdecl());
      break;
    }
    case kEnumConstant: {
      _this->_internal_mutable_enumconstant()->::Backage::EnumConstant::MergeFrom(
          from._internal_enumconstant());
      break;
    }
    case kVaraibleDecl: {
      _this->_internal_mutable_varaibledecl()->::Backage::VariableDecl::MergeFrom(
          from._internal_varaibledecl());
      break;
    }
    case kModuleDecl: {
      _this->_internal_mutable_moduledecl()->::Backage::ModuleDecl::MergeFrom(
          from._internal_moduledecl());
      break;
    }
    case kMethodDecl: {
      _this->_internal_mutable_methoddecl()->::Backage::MethodDecl::MergeFrom(
          from._internal_methoddecl());
      break;
    }
    case kCtorDecl: {
      _this->_internal_mutable_ctordecl()->::Backage::CtorDecl::MergeFrom(
          from._internal_ctordecl());
      break;
    }
    case kForeignEntryDecl: {
      _this->_internal_mutable_foreignentrydecl()->::Backage::ForeignEntryDecl::MergeFrom(
          from._internal_foreignentrydecl());
      break;
    }
    case MEMBER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Backage.Declaration)
}

inline void Declaration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.Member_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_Member();
}

Declaration::~Declaration() {
  // @@protoc_insertion_point(destructor:Backage.Declaration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Declaration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Member()) {
    clear_Member();
  }
}

void Declaration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Declaration::clear_Member() {
// @@protoc_insertion_point(one_of_clear_start:Backage.Declaration)
  switch (Member_case()) {
    case kClassDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Member_.classdecl_;
      }
      break;
    }
    case kRecordDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Member_.recorddecl_;
      }
      break;
    }
    case kEnumDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Member_.enumdecl_;
      }
      break;
    }
    case kEnumConstant: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Member_.enumconstant_;
      }
      break;
    }
    case kVaraibleDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Member_.varaibledecl_;
      }
      break;
    }
    case kModuleDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Member_.moduledecl_;
      }
      break;
    }
    case kMethodDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Member_.methoddecl_;
      }
      break;
    }
    case kCtorDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Member_.ctordecl_;
      }
      break;
    }
    case kForeignEntryDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Member_.foreignentrydecl_;
      }
      break;
    }
    case MEMBER_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MEMBER_NOT_SET;
}


void Declaration::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.Declaration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_Member();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Declaration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Backage.ClassDecl classDecl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_classdecl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.RecordDecl recordDecl = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_recorddecl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.EnumDecl enumDecl = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_enumdecl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.EnumConstant enumConstant = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_enumconstant(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.VariableDecl varaibleDecl = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_varaibledecl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.ModuleDecl moduleDecl = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_moduledecl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.MethodDecl methodDecl = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_methoddecl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.CtorDecl ctorDecl = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_ctordecl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Backage.ForeignEntryDecl foreignEntryDecl = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_foreignentrydecl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Declaration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.Declaration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Backage.ClassDecl classDecl = 1;
  if (_internal_has_classdecl()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::classdecl(this),
        _Internal::classdecl(this).GetCachedSize(), target, stream);
  }

  // .Backage.RecordDecl recordDecl = 2;
  if (_internal_has_recorddecl()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::recorddecl(this),
        _Internal::recorddecl(this).GetCachedSize(), target, stream);
  }

  // .Backage.EnumDecl enumDecl = 3;
  if (_internal_has_enumdecl()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::enumdecl(this),
        _Internal::enumdecl(this).GetCachedSize(), target, stream);
  }

  // .Backage.EnumConstant enumConstant = 4;
  if (_internal_has_enumconstant()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::enumconstant(this),
        _Internal::enumconstant(this).GetCachedSize(), target, stream);
  }

  // .Backage.VariableDecl varaibleDecl = 5;
  if (_internal_has_varaibledecl()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::varaibledecl(this),
        _Internal::varaibledecl(this).GetCachedSize(), target, stream);
  }

  // .Backage.ModuleDecl moduleDecl = 6;
  if (_internal_has_moduledecl()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::moduledecl(this),
        _Internal::moduledecl(this).GetCachedSize(), target, stream);
  }

  // .Backage.MethodDecl methodDecl = 7;
  if (_internal_has_methoddecl()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::methoddecl(this),
        _Internal::methoddecl(this).GetCachedSize(), target, stream);
  }

  // .Backage.CtorDecl ctorDecl = 8;
  if (_internal_has_ctordecl()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::ctordecl(this),
        _Internal::ctordecl(this).GetCachedSize(), target, stream);
  }

  // .Backage.ForeignEntryDecl foreignEntryDecl = 9;
  if (_internal_has_foreignentrydecl()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::foreignentrydecl(this),
        _Internal::foreignentrydecl(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.Declaration)
  return target;
}

size_t Declaration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.Declaration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Member_case()) {
    // .Backage.ClassDecl classDecl = 1;
    case kClassDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Member_.classdecl_);
      break;
    }
    // .Backage.RecordDecl recordDecl = 2;
    case kRecordDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Member_.recorddecl_);
      break;
    }
    // .Backage.EnumDecl enumDecl = 3;
    case kEnumDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Member_.enumdecl_);
      break;
    }
    // .Backage.EnumConstant enumConstant = 4;
    case kEnumConstant: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Member_.enumconstant_);
      break;
    }
    // .Backage.VariableDecl varaibleDecl = 5;
    case kVaraibleDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Member_.varaibledecl_);
      break;
    }
    // .Backage.ModuleDecl moduleDecl = 6;
    case kModuleDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Member_.moduledecl_);
      break;
    }
    // .Backage.MethodDecl methodDecl = 7;
    case kMethodDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Member_.methoddecl_);
      break;
    }
    // .Backage.CtorDecl ctorDecl = 8;
    case kCtorDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Member_.ctordecl_);
      break;
    }
    // .Backage.ForeignEntryDecl foreignEntryDecl = 9;
    case kForeignEntryDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Member_.foreignentrydecl_);
      break;
    }
    case MEMBER_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Declaration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Declaration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Declaration::GetClassData() const { return &_class_data_; }


void Declaration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Declaration*>(&to_msg);
  auto& from = static_cast<const Declaration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.Declaration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.Member_case()) {
    case kClassDecl: {
      _this->_internal_mutable_classdecl()->::Backage::ClassDecl::MergeFrom(
          from._internal_classdecl());
      break;
    }
    case kRecordDecl: {
      _this->_internal_mutable_recorddecl()->::Backage::RecordDecl::MergeFrom(
          from._internal_recorddecl());
      break;
    }
    case kEnumDecl: {
      _this->_internal_mutable_enumdecl()->::Backage::EnumDecl::MergeFrom(
          from._internal_enumdecl());
      break;
    }
    case kEnumConstant: {
      _this->_internal_mutable_enumconstant()->::Backage::EnumConstant::MergeFrom(
          from._internal_enumconstant());
      break;
    }
    case kVaraibleDecl: {
      _this->_internal_mutable_varaibledecl()->::Backage::VariableDecl::MergeFrom(
          from._internal_varaibledecl());
      break;
    }
    case kModuleDecl: {
      _this->_internal_mutable_moduledecl()->::Backage::ModuleDecl::MergeFrom(
          from._internal_moduledecl());
      break;
    }
    case kMethodDecl: {
      _this->_internal_mutable_methoddecl()->::Backage::MethodDecl::MergeFrom(
          from._internal_methoddecl());
      break;
    }
    case kCtorDecl: {
      _this->_internal_mutable_ctordecl()->::Backage::CtorDecl::MergeFrom(
          from._internal_ctordecl());
      break;
    }
    case kForeignEntryDecl: {
      _this->_internal_mutable_foreignentrydecl()->::Backage::ForeignEntryDecl::MergeFrom(
          from._internal_foreignentrydecl());
      break;
    }
    case MEMBER_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Declaration::CopyFrom(const Declaration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.Declaration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Declaration::IsInitialized() const {
  return true;
}

void Declaration::InternalSwap(Declaration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.Member_, other->_impl_.Member_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Declaration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[6]);
}

// ===================================================================

class ClassDecl::_Internal {
 public:
};

ClassDecl::ClassDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.ClassDecl)
}
ClassDecl::ClassDecl(const ClassDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClassDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.impltoken_){from._impl_.impltoken_}
    , /*decltype(_impl_._impltoken_cached_byte_size_)*/{0}
    , decltype(_impl_.declarations_){from._impl_.declarations_}
    , decltype(_impl_.flag_){}
    , decltype(_impl_.nametoken_){}
    , decltype(_impl_.basetoken_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.flag_, &from._impl_.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.basetoken_) -
    reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.basetoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.ClassDecl)
}

inline void ClassDecl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.impltoken_){arena}
    , /*decltype(_impl_._impltoken_cached_byte_size_)*/{0}
    , decltype(_impl_.declarations_){arena}
    , decltype(_impl_.flag_){0u}
    , decltype(_impl_.nametoken_){0u}
    , decltype(_impl_.basetoken_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ClassDecl::~ClassDecl() {
  // @@protoc_insertion_point(destructor:Backage.ClassDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClassDecl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.impltoken_.~RepeatedField();
  _impl_.declarations_.~RepeatedPtrField();
}

void ClassDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClassDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.ClassDecl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.impltoken_.Clear();
  _impl_.declarations_.Clear();
  ::memset(&_impl_.flag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.basetoken_) -
      reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.basetoken_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClassDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nameToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nametoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 baseToken = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.basetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 implToken = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_impltoken(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_impltoken(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.Declaration declarations = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_declarations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClassDecl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.ClassDecl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flag(), target);
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nametoken(), target);
  }

  // uint32 baseToken = 3;
  if (this->_internal_basetoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_basetoken(), target);
  }

  // repeated uint32 implToken = 4;
  {
    int byte_size = _impl_._impltoken_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          4, _internal_impltoken(), byte_size, target);
    }
  }

  // repeated .Backage.Declaration declarations = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_declarations_size()); i < n; i++) {
    const auto& repfield = this->_internal_declarations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.ClassDecl)
  return target;
}

size_t ClassDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.ClassDecl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 implToken = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.impltoken_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._impltoken_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .Backage.Declaration declarations = 5;
  total_size += 1UL * this->_internal_declarations_size();
  for (const auto& msg : this->_impl_.declarations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nametoken());
  }

  // uint32 baseToken = 3;
  if (this->_internal_basetoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_basetoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClassDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClassDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClassDecl::GetClassData() const { return &_class_data_; }


void ClassDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClassDecl*>(&to_msg);
  auto& from = static_cast<const ClassDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.ClassDecl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.impltoken_.MergeFrom(from._impl_.impltoken_);
  _this->_impl_.declarations_.MergeFrom(from._impl_.declarations_);
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  if (from._internal_nametoken() != 0) {
    _this->_internal_set_nametoken(from._internal_nametoken());
  }
  if (from._internal_basetoken() != 0) {
    _this->_internal_set_basetoken(from._internal_basetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClassDecl::CopyFrom(const ClassDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.ClassDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClassDecl::IsInitialized() const {
  return true;
}

void ClassDecl::InternalSwap(ClassDecl* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.impltoken_.InternalSwap(&other->_impl_.impltoken_);
  _impl_.declarations_.InternalSwap(&other->_impl_.declarations_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClassDecl, _impl_.basetoken_)
      + sizeof(ClassDecl::_impl_.basetoken_)
      - PROTOBUF_FIELD_OFFSET(ClassDecl, _impl_.flag_)>(
          reinterpret_cast<char*>(&_impl_.flag_),
          reinterpret_cast<char*>(&other->_impl_.flag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClassDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[7]);
}

// ===================================================================

class RecordDecl::_Internal {
 public:
};

RecordDecl::RecordDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.RecordDecl)
}
RecordDecl::RecordDecl(const RecordDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecordDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.declarations_){from._impl_.declarations_}
    , decltype(_impl_.flag_){}
    , decltype(_impl_.nametoken_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.flag_, &from._impl_.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nametoken_) -
    reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.nametoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.RecordDecl)
}

inline void RecordDecl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.declarations_){arena}
    , decltype(_impl_.flag_){0u}
    , decltype(_impl_.nametoken_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RecordDecl::~RecordDecl() {
  // @@protoc_insertion_point(destructor:Backage.RecordDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecordDecl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.declarations_.~RepeatedPtrField();
}

void RecordDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecordDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.RecordDecl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.declarations_.Clear();
  ::memset(&_impl_.flag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nametoken_) -
      reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.nametoken_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecordDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nameToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nametoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.Declaration declarations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_declarations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RecordDecl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.RecordDecl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flag(), target);
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nametoken(), target);
  }

  // repeated .Backage.Declaration declarations = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_declarations_size()); i < n; i++) {
    const auto& repfield = this->_internal_declarations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.RecordDecl)
  return target;
}

size_t RecordDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.RecordDecl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Backage.Declaration declarations = 3;
  total_size += 1UL * this->_internal_declarations_size();
  for (const auto& msg : this->_impl_.declarations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nametoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecordDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecordDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecordDecl::GetClassData() const { return &_class_data_; }


void RecordDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecordDecl*>(&to_msg);
  auto& from = static_cast<const RecordDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.RecordDecl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.declarations_.MergeFrom(from._impl_.declarations_);
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  if (from._internal_nametoken() != 0) {
    _this->_internal_set_nametoken(from._internal_nametoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecordDecl::CopyFrom(const RecordDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.RecordDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecordDecl::IsInitialized() const {
  return true;
}

void RecordDecl::InternalSwap(RecordDecl* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.declarations_.InternalSwap(&other->_impl_.declarations_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RecordDecl, _impl_.nametoken_)
      + sizeof(RecordDecl::_impl_.nametoken_)
      - PROTOBUF_FIELD_OFFSET(RecordDecl, _impl_.flag_)>(
          reinterpret_cast<char*>(&_impl_.flag_),
          reinterpret_cast<char*>(&other->_impl_.flag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RecordDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[8]);
}

// ===================================================================

class EnumDecl::_Internal {
 public:
};

EnumDecl::EnumDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.EnumDecl)
}
EnumDecl::EnumDecl(const EnumDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnumDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.constants_){from._impl_.constants_}
    , decltype(_impl_.flag_){}
    , decltype(_impl_.nametoken_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.flag_, &from._impl_.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nametoken_) -
    reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.nametoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.EnumDecl)
}

inline void EnumDecl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.constants_){arena}
    , decltype(_impl_.flag_){0u}
    , decltype(_impl_.nametoken_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EnumDecl::~EnumDecl() {
  // @@protoc_insertion_point(destructor:Backage.EnumDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnumDecl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.constants_.~RepeatedPtrField();
}

void EnumDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnumDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.EnumDecl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.constants_.Clear();
  ::memset(&_impl_.flag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nametoken_) -
      reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.nametoken_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnumDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nameToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nametoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.EnumConstant constants = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_constants(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnumDecl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.EnumDecl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flag(), target);
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nametoken(), target);
  }

  // repeated .Backage.EnumConstant constants = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_constants_size()); i < n; i++) {
    const auto& repfield = this->_internal_constants(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.EnumDecl)
  return target;
}

size_t EnumDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.EnumDecl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Backage.EnumConstant constants = 3;
  total_size += 1UL * this->_internal_constants_size();
  for (const auto& msg : this->_impl_.constants_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nametoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnumDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnumDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnumDecl::GetClassData() const { return &_class_data_; }


void EnumDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnumDecl*>(&to_msg);
  auto& from = static_cast<const EnumDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.EnumDecl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.constants_.MergeFrom(from._impl_.constants_);
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  if (from._internal_nametoken() != 0) {
    _this->_internal_set_nametoken(from._internal_nametoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnumDecl::CopyFrom(const EnumDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.EnumDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnumDecl::IsInitialized() const {
  return true;
}

void EnumDecl::InternalSwap(EnumDecl* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.constants_.InternalSwap(&other->_impl_.constants_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnumDecl, _impl_.nametoken_)
      + sizeof(EnumDecl::_impl_.nametoken_)
      - PROTOBUF_FIELD_OFFSET(EnumDecl, _impl_.flag_)>(
          reinterpret_cast<char*>(&_impl_.flag_),
          reinterpret_cast<char*>(&other->_impl_.flag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnumDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[9]);
}

// ===================================================================

class EnumConstant::_Internal {
 public:
};

EnumConstant::EnumConstant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.EnumConstant)
}
EnumConstant::EnumConstant(const EnumConstant& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnumConstant* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nametoken_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.nametoken_, &from._impl_.nametoken_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.nametoken_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:Backage.EnumConstant)
}

inline void EnumConstant::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nametoken_){0u}
    , decltype(_impl_.value_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EnumConstant::~EnumConstant() {
  // @@protoc_insertion_point(destructor:Backage.EnumConstant)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnumConstant::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EnumConstant::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnumConstant::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.EnumConstant)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.nametoken_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.value_) -
      reinterpret_cast<char*>(&_impl_.nametoken_)) + sizeof(_impl_.value_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnumConstant::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 nameToken = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nametoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnumConstant::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.EnumConstant)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 nameToken = 1;
  if (this->_internal_nametoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_nametoken(), target);
  }

  // uint32 value = 2;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.EnumConstant)
  return target;
}

size_t EnumConstant::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.EnumConstant)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 nameToken = 1;
  if (this->_internal_nametoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nametoken());
  }

  // uint32 value = 2;
  if (this->_internal_value() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnumConstant::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnumConstant::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnumConstant::GetClassData() const { return &_class_data_; }


void EnumConstant::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnumConstant*>(&to_msg);
  auto& from = static_cast<const EnumConstant&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.EnumConstant)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_nametoken() != 0) {
    _this->_internal_set_nametoken(from._internal_nametoken());
  }
  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnumConstant::CopyFrom(const EnumConstant& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.EnumConstant)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnumConstant::IsInitialized() const {
  return true;
}

void EnumConstant::InternalSwap(EnumConstant* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnumConstant, _impl_.value_)
      + sizeof(EnumConstant::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(EnumConstant, _impl_.nametoken_)>(
          reinterpret_cast<char*>(&_impl_.nametoken_),
          reinterpret_cast<char*>(&other->_impl_.nametoken_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnumConstant::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[10]);
}

// ===================================================================

class VariableDecl::_Internal {
 public:
  using HasBits = decltype(std::declval<VariableDecl>()._impl_._has_bits_);
  static void set_has_initial(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

VariableDecl::VariableDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.VariableDecl)
}
VariableDecl::VariableDecl(const VariableDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VariableDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.initial_){}
    , decltype(_impl_.flag_){}
    , decltype(_impl_.nametoken_){}
    , decltype(_impl_.typetoken_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.initial_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initial_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_initial()) {
    _this->_impl_.initial_.Set(from._internal_initial(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flag_, &from._impl_.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.typetoken_) -
    reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.typetoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.VariableDecl)
}

inline void VariableDecl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.initial_){}
    , decltype(_impl_.flag_){0u}
    , decltype(_impl_.nametoken_){0u}
    , decltype(_impl_.typetoken_){0u}
  };
  _impl_.initial_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initial_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VariableDecl::~VariableDecl() {
  // @@protoc_insertion_point(destructor:Backage.VariableDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VariableDecl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.initial_.Destroy();
}

void VariableDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VariableDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.VariableDecl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.initial_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.flag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.typetoken_) -
      reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.typetoken_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VariableDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nameToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nametoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 typeToken = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.typetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes initial = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_initial();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VariableDecl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.VariableDecl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flag(), target);
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nametoken(), target);
  }

  // uint32 typeToken = 3;
  if (this->_internal_typetoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_typetoken(), target);
  }

  // optional bytes initial = 4;
  if (_internal_has_initial()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_initial(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.VariableDecl)
  return target;
}

size_t VariableDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.VariableDecl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes initial = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_initial());
  }

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nametoken());
  }

  // uint32 typeToken = 3;
  if (this->_internal_typetoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_typetoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VariableDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VariableDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VariableDecl::GetClassData() const { return &_class_data_; }


void VariableDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VariableDecl*>(&to_msg);
  auto& from = static_cast<const VariableDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.VariableDecl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_initial()) {
    _this->_internal_set_initial(from._internal_initial());
  }
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  if (from._internal_nametoken() != 0) {
    _this->_internal_set_nametoken(from._internal_nametoken());
  }
  if (from._internal_typetoken() != 0) {
    _this->_internal_set_typetoken(from._internal_typetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VariableDecl::CopyFrom(const VariableDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.VariableDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VariableDecl::IsInitialized() const {
  return true;
}

void VariableDecl::InternalSwap(VariableDecl* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.initial_, lhs_arena,
      &other->_impl_.initial_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VariableDecl, _impl_.typetoken_)
      + sizeof(VariableDecl::_impl_.typetoken_)
      - PROTOBUF_FIELD_OFFSET(VariableDecl, _impl_.flag_)>(
          reinterpret_cast<char*>(&_impl_.flag_),
          reinterpret_cast<char*>(&other->_impl_.flag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VariableDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[11]);
}

// ===================================================================

class ParameterDecl::_Internal {
 public:
  using HasBits = decltype(std::declval<ParameterDecl>()._impl_._has_bits_);
  static void set_has_initial(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ParameterDecl::ParameterDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.ParameterDecl)
}
ParameterDecl::ParameterDecl(const ParameterDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ParameterDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.initial_){}
    , decltype(_impl_.flag_){}
    , decltype(_impl_.nametoken_){}
    , decltype(_impl_.typetoken_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.initial_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initial_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_initial()) {
    _this->_impl_.initial_.Set(from._internal_initial(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flag_, &from._impl_.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.typetoken_) -
    reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.typetoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.ParameterDecl)
}

inline void ParameterDecl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.initial_){}
    , decltype(_impl_.flag_){0u}
    , decltype(_impl_.nametoken_){0u}
    , decltype(_impl_.typetoken_){0u}
  };
  _impl_.initial_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initial_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ParameterDecl::~ParameterDecl() {
  // @@protoc_insertion_point(destructor:Backage.ParameterDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ParameterDecl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.initial_.Destroy();
}

void ParameterDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ParameterDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.ParameterDecl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.initial_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.flag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.typetoken_) -
      reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.typetoken_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ParameterDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nameToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nametoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 typeToken = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.typetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes initial = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_initial();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ParameterDecl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.ParameterDecl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flag(), target);
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nametoken(), target);
  }

  // uint32 typeToken = 3;
  if (this->_internal_typetoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_typetoken(), target);
  }

  // optional bytes initial = 4;
  if (_internal_has_initial()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_initial(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.ParameterDecl)
  return target;
}

size_t ParameterDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.ParameterDecl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes initial = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_initial());
  }

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nametoken());
  }

  // uint32 typeToken = 3;
  if (this->_internal_typetoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_typetoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ParameterDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ParameterDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ParameterDecl::GetClassData() const { return &_class_data_; }


void ParameterDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ParameterDecl*>(&to_msg);
  auto& from = static_cast<const ParameterDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.ParameterDecl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_initial()) {
    _this->_internal_set_initial(from._internal_initial());
  }
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  if (from._internal_nametoken() != 0) {
    _this->_internal_set_nametoken(from._internal_nametoken());
  }
  if (from._internal_typetoken() != 0) {
    _this->_internal_set_typetoken(from._internal_typetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ParameterDecl::CopyFrom(const ParameterDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.ParameterDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParameterDecl::IsInitialized() const {
  return true;
}

void ParameterDecl::InternalSwap(ParameterDecl* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.initial_, lhs_arena,
      &other->_impl_.initial_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ParameterDecl, _impl_.typetoken_)
      + sizeof(ParameterDecl::_impl_.typetoken_)
      - PROTOBUF_FIELD_OFFSET(ParameterDecl, _impl_.flag_)>(
          reinterpret_cast<char*>(&_impl_.flag_),
          reinterpret_cast<char*>(&other->_impl_.flag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ParameterDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[12]);
}

// ===================================================================

class ModuleDecl::_Internal {
 public:
};

ModuleDecl::ModuleDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.ModuleDecl)
}
ModuleDecl::ModuleDecl(const ModuleDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.declarations_){from._impl_.declarations_}
    , decltype(_impl_.flag_){}
    , decltype(_impl_.nametoken_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.flag_, &from._impl_.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nametoken_) -
    reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.nametoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.ModuleDecl)
}

inline void ModuleDecl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.declarations_){arena}
    , decltype(_impl_.flag_){0u}
    , decltype(_impl_.nametoken_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleDecl::~ModuleDecl() {
  // @@protoc_insertion_point(destructor:Backage.ModuleDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleDecl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.declarations_.~RepeatedPtrField();
}

void ModuleDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.ModuleDecl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.declarations_.Clear();
  ::memset(&_impl_.flag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nametoken_) -
      reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.nametoken_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nameToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nametoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.Declaration declarations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_declarations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleDecl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.ModuleDecl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flag(), target);
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nametoken(), target);
  }

  // repeated .Backage.Declaration declarations = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_declarations_size()); i < n; i++) {
    const auto& repfield = this->_internal_declarations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.ModuleDecl)
  return target;
}

size_t ModuleDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.ModuleDecl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Backage.Declaration declarations = 3;
  total_size += 1UL * this->_internal_declarations_size();
  for (const auto& msg : this->_impl_.declarations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nametoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleDecl::GetClassData() const { return &_class_data_; }


void ModuleDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleDecl*>(&to_msg);
  auto& from = static_cast<const ModuleDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.ModuleDecl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.declarations_.MergeFrom(from._impl_.declarations_);
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  if (from._internal_nametoken() != 0) {
    _this->_internal_set_nametoken(from._internal_nametoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleDecl::CopyFrom(const ModuleDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.ModuleDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleDecl::IsInitialized() const {
  return true;
}

void ModuleDecl::InternalSwap(ModuleDecl* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.declarations_.InternalSwap(&other->_impl_.declarations_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleDecl, _impl_.nametoken_)
      + sizeof(ModuleDecl::_impl_.nametoken_)
      - PROTOBUF_FIELD_OFFSET(ModuleDecl, _impl_.flag_)>(
          reinterpret_cast<char*>(&_impl_.flag_),
          reinterpret_cast<char*>(&other->_impl_.flag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[13]);
}

// ===================================================================

class LocalIndex::_Internal {
 public:
};

LocalIndex::LocalIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.LocalIndex)
}
LocalIndex::LocalIndex(const LocalIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LocalIndex* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.typetoken_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.typetoken_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.typetoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.LocalIndex)
}

inline void LocalIndex::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){0u}
    , decltype(_impl_.typetoken_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LocalIndex::~LocalIndex() {
  // @@protoc_insertion_point(destructor:Backage.LocalIndex)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LocalIndex::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.LocalIndex)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.typetoken_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.typetoken_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocalIndex::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 typeToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.typetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalIndex::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.LocalIndex)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // uint32 typeToken = 2;
  if (this->_internal_typetoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_typetoken(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.LocalIndex)
  return target;
}

size_t LocalIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.LocalIndex)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // uint32 typeToken = 2;
  if (this->_internal_typetoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_typetoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocalIndex::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LocalIndex::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocalIndex::GetClassData() const { return &_class_data_; }


void LocalIndex::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LocalIndex*>(&to_msg);
  auto& from = static_cast<const LocalIndex&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.LocalIndex)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_typetoken() != 0) {
    _this->_internal_set_typetoken(from._internal_typetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocalIndex::CopyFrom(const LocalIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.LocalIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalIndex::IsInitialized() const {
  return true;
}

void LocalIndex::InternalSwap(LocalIndex* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LocalIndex, _impl_.typetoken_)
      + sizeof(LocalIndex::_impl_.typetoken_)
      - PROTOBUF_FIELD_OFFSET(LocalIndex, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LocalIndex::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[14]);
}

// ===================================================================

class MethodDecl::_Internal {
 public:
};

MethodDecl::MethodDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.MethodDecl)
}
MethodDecl::MethodDecl(const MethodDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MethodDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){from._impl_.params_}
    , decltype(_impl_.localindex_){from._impl_.localindex_}
    , decltype(_impl_.linenumbers_){from._impl_.linenumbers_}
    , decltype(_impl_.exceptionentry_){from._impl_.exceptionentry_}
    , decltype(_impl_.block_){}
    , decltype(_impl_.flag_){}
    , decltype(_impl_.nametoken_){}
    , decltype(_impl_.rettypetoken_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.block_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block().empty()) {
    _this->_impl_.block_.Set(from._internal_block(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flag_, &from._impl_.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rettypetoken_) -
    reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.rettypetoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.MethodDecl)
}

inline void MethodDecl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){arena}
    , decltype(_impl_.localindex_){arena}
    , decltype(_impl_.linenumbers_){arena}
    , decltype(_impl_.exceptionentry_){arena}
    , decltype(_impl_.block_){}
    , decltype(_impl_.flag_){0u}
    , decltype(_impl_.nametoken_){0u}
    , decltype(_impl_.rettypetoken_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.block_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MethodDecl::~MethodDecl() {
  // @@protoc_insertion_point(destructor:Backage.MethodDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MethodDecl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.params_.~RepeatedPtrField();
  _impl_.localindex_.~RepeatedPtrField();
  _impl_.linenumbers_.~RepeatedPtrField();
  _impl_.exceptionentry_.~RepeatedPtrField();
  _impl_.block_.Destroy();
}

void MethodDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MethodDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.MethodDecl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.params_.Clear();
  _impl_.localindex_.Clear();
  _impl_.linenumbers_.Clear();
  _impl_.exceptionentry_.Clear();
  _impl_.block_.ClearToEmpty();
  ::memset(&_impl_.flag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.rettypetoken_) -
      reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.rettypetoken_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MethodDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nameToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nametoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.ParameterDecl params = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 retTypeToken = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.rettypetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.LocalIndex localIndex = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_localindex(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes block = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_block();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.LineNumber lineNumbers = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_linenumbers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.ExceptionEntry exceptionEntry = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exceptionentry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MethodDecl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.MethodDecl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flag(), target);
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nametoken(), target);
  }

  // repeated .Backage.ParameterDecl params = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 retTypeToken = 4;
  if (this->_internal_rettypetoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rettypetoken(), target);
  }

  // repeated .Backage.LocalIndex localIndex = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_localindex_size()); i < n; i++) {
    const auto& repfield = this->_internal_localindex(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bytes block = 6;
  if (!this->_internal_block().empty()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_block(), target);
  }

  // repeated .Backage.LineNumber lineNumbers = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_linenumbers_size()); i < n; i++) {
    const auto& repfield = this->_internal_linenumbers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Backage.ExceptionEntry exceptionEntry = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exceptionentry_size()); i < n; i++) {
    const auto& repfield = this->_internal_exceptionentry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.MethodDecl)
  return target;
}

size_t MethodDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.MethodDecl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Backage.ParameterDecl params = 3;
  total_size += 1UL * this->_internal_params_size();
  for (const auto& msg : this->_impl_.params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Backage.LocalIndex localIndex = 5;
  total_size += 1UL * this->_internal_localindex_size();
  for (const auto& msg : this->_impl_.localindex_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Backage.LineNumber lineNumbers = 7;
  total_size += 1UL * this->_internal_linenumbers_size();
  for (const auto& msg : this->_impl_.linenumbers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Backage.ExceptionEntry exceptionEntry = 8;
  total_size += 1UL * this->_internal_exceptionentry_size();
  for (const auto& msg : this->_impl_.exceptionentry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes block = 6;
  if (!this->_internal_block().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_block());
  }

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nametoken());
  }

  // uint32 retTypeToken = 4;
  if (this->_internal_rettypetoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rettypetoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MethodDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MethodDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MethodDecl::GetClassData() const { return &_class_data_; }


void MethodDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MethodDecl*>(&to_msg);
  auto& from = static_cast<const MethodDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.MethodDecl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.params_.MergeFrom(from._impl_.params_);
  _this->_impl_.localindex_.MergeFrom(from._impl_.localindex_);
  _this->_impl_.linenumbers_.MergeFrom(from._impl_.linenumbers_);
  _this->_impl_.exceptionentry_.MergeFrom(from._impl_.exceptionentry_);
  if (!from._internal_block().empty()) {
    _this->_internal_set_block(from._internal_block());
  }
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  if (from._internal_nametoken() != 0) {
    _this->_internal_set_nametoken(from._internal_nametoken());
  }
  if (from._internal_rettypetoken() != 0) {
    _this->_internal_set_rettypetoken(from._internal_rettypetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MethodDecl::CopyFrom(const MethodDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.MethodDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MethodDecl::IsInitialized() const {
  return true;
}

void MethodDecl::InternalSwap(MethodDecl* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.params_.InternalSwap(&other->_impl_.params_);
  _impl_.localindex_.InternalSwap(&other->_impl_.localindex_);
  _impl_.linenumbers_.InternalSwap(&other->_impl_.linenumbers_);
  _impl_.exceptionentry_.InternalSwap(&other->_impl_.exceptionentry_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.block_, lhs_arena,
      &other->_impl_.block_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MethodDecl, _impl_.rettypetoken_)
      + sizeof(MethodDecl::_impl_.rettypetoken_)
      - PROTOBUF_FIELD_OFFSET(MethodDecl, _impl_.flag_)>(
          reinterpret_cast<char*>(&_impl_.flag_),
          reinterpret_cast<char*>(&other->_impl_.flag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MethodDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[15]);
}

// ===================================================================

class CtorDecl::_Internal {
 public:
};

CtorDecl::CtorDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.CtorDecl)
}
CtorDecl::CtorDecl(const CtorDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CtorDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){from._impl_.params_}
    , decltype(_impl_.localindex_){from._impl_.localindex_}
    , decltype(_impl_.linenumbers_){from._impl_.linenumbers_}
    , decltype(_impl_.exceptionentry_){from._impl_.exceptionentry_}
    , decltype(_impl_.block_){}
    , decltype(_impl_.flag_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.block_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block().empty()) {
    _this->_impl_.block_.Set(from._internal_block(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.flag_ = from._impl_.flag_;
  // @@protoc_insertion_point(copy_constructor:Backage.CtorDecl)
}

inline void CtorDecl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){arena}
    , decltype(_impl_.localindex_){arena}
    , decltype(_impl_.linenumbers_){arena}
    , decltype(_impl_.exceptionentry_){arena}
    , decltype(_impl_.block_){}
    , decltype(_impl_.flag_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.block_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CtorDecl::~CtorDecl() {
  // @@protoc_insertion_point(destructor:Backage.CtorDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CtorDecl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.params_.~RepeatedPtrField();
  _impl_.localindex_.~RepeatedPtrField();
  _impl_.linenumbers_.~RepeatedPtrField();
  _impl_.exceptionentry_.~RepeatedPtrField();
  _impl_.block_.Destroy();
}

void CtorDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CtorDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.CtorDecl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.params_.Clear();
  _impl_.localindex_.Clear();
  _impl_.linenumbers_.Clear();
  _impl_.exceptionentry_.Clear();
  _impl_.block_.ClearToEmpty();
  _impl_.flag_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CtorDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.ParameterDecl params = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.LocalIndex localIndex = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_localindex(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes block = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_block();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.LineNumber lineNumbers = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_linenumbers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.ExceptionEntry exceptionEntry = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exceptionentry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CtorDecl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.CtorDecl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flag(), target);
  }

  // repeated .Backage.ParameterDecl params = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Backage.LocalIndex localIndex = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_localindex_size()); i < n; i++) {
    const auto& repfield = this->_internal_localindex(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bytes block = 4;
  if (!this->_internal_block().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_block(), target);
  }

  // repeated .Backage.LineNumber lineNumbers = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_linenumbers_size()); i < n; i++) {
    const auto& repfield = this->_internal_linenumbers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Backage.ExceptionEntry exceptionEntry = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exceptionentry_size()); i < n; i++) {
    const auto& repfield = this->_internal_exceptionentry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.CtorDecl)
  return target;
}

size_t CtorDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.CtorDecl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Backage.ParameterDecl params = 2;
  total_size += 1UL * this->_internal_params_size();
  for (const auto& msg : this->_impl_.params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Backage.LocalIndex localIndex = 3;
  total_size += 1UL * this->_internal_localindex_size();
  for (const auto& msg : this->_impl_.localindex_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Backage.LineNumber lineNumbers = 5;
  total_size += 1UL * this->_internal_linenumbers_size();
  for (const auto& msg : this->_impl_.linenumbers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Backage.ExceptionEntry exceptionEntry = 6;
  total_size += 1UL * this->_internal_exceptionentry_size();
  for (const auto& msg : this->_impl_.exceptionentry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes block = 4;
  if (!this->_internal_block().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_block());
  }

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CtorDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CtorDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CtorDecl::GetClassData() const { return &_class_data_; }


void CtorDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CtorDecl*>(&to_msg);
  auto& from = static_cast<const CtorDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.CtorDecl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.params_.MergeFrom(from._impl_.params_);
  _this->_impl_.localindex_.MergeFrom(from._impl_.localindex_);
  _this->_impl_.linenumbers_.MergeFrom(from._impl_.linenumbers_);
  _this->_impl_.exceptionentry_.MergeFrom(from._impl_.exceptionentry_);
  if (!from._internal_block().empty()) {
    _this->_internal_set_block(from._internal_block());
  }
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CtorDecl::CopyFrom(const CtorDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.CtorDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CtorDecl::IsInitialized() const {
  return true;
}

void CtorDecl::InternalSwap(CtorDecl* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.params_.InternalSwap(&other->_impl_.params_);
  _impl_.localindex_.InternalSwap(&other->_impl_.localindex_);
  _impl_.linenumbers_.InternalSwap(&other->_impl_.linenumbers_);
  _impl_.exceptionentry_.InternalSwap(&other->_impl_.exceptionentry_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.block_, lhs_arena,
      &other->_impl_.block_, rhs_arena
  );
  swap(_impl_.flag_, other->_impl_.flag_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CtorDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[16]);
}

// ===================================================================

class ForeignEntryDecl::_Internal {
 public:
  using HasBits = decltype(std::declval<ForeignEntryDecl>()._impl_._has_bits_);
  static void set_has_lib(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alias(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ForeignEntryDecl::ForeignEntryDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.ForeignEntryDecl)
}
ForeignEntryDecl::ForeignEntryDecl(const ForeignEntryDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ForeignEntryDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.params_){from._impl_.params_}
    , decltype(_impl_.block_){}
    , decltype(_impl_.lib_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.flag_){}
    , decltype(_impl_.nametoken_){}
    , decltype(_impl_.rettypetoken_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.block_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block().empty()) {
    _this->_impl_.block_.Set(from._internal_block(), 
      _this->GetArenaForAllocation());
  }
  _impl_.lib_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lib_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_lib()) {
    _this->_impl_.lib_.Set(from._internal_lib(), 
      _this->GetArenaForAllocation());
  }
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_alias()) {
    _this->_impl_.alias_.Set(from._internal_alias(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flag_, &from._impl_.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rettypetoken_) -
    reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.rettypetoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.ForeignEntryDecl)
}

inline void ForeignEntryDecl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.params_){arena}
    , decltype(_impl_.block_){}
    , decltype(_impl_.lib_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.flag_){0u}
    , decltype(_impl_.nametoken_){0u}
    , decltype(_impl_.rettypetoken_){0u}
  };
  _impl_.block_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lib_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lib_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ForeignEntryDecl::~ForeignEntryDecl() {
  // @@protoc_insertion_point(destructor:Backage.ForeignEntryDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ForeignEntryDecl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.params_.~RepeatedPtrField();
  _impl_.block_.Destroy();
  _impl_.lib_.Destroy();
  _impl_.alias_.Destroy();
}

void ForeignEntryDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ForeignEntryDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.ForeignEntryDecl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.params_.Clear();
  _impl_.block_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.lib_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.alias_.ClearNonDefaultToEmpty();
    }
  }
  ::memset(&_impl_.flag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.rettypetoken_) -
      reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.rettypetoken_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ForeignEntryDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nameToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nametoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Backage.ParameterDecl params = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 retTypeToken = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.rettypetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes block = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_block();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes lib = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_lib();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes alias = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_alias();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ForeignEntryDecl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.ForeignEntryDecl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flag(), target);
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nametoken(), target);
  }

  // repeated .Backage.ParameterDecl params = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 retTypeToken = 4;
  if (this->_internal_rettypetoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rettypetoken(), target);
  }

  // bytes block = 5;
  if (!this->_internal_block().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_block(), target);
  }

  // optional bytes lib = 6;
  if (_internal_has_lib()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_lib(), target);
  }

  // optional bytes alias = 7;
  if (_internal_has_alias()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_alias(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.ForeignEntryDecl)
  return target;
}

size_t ForeignEntryDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.ForeignEntryDecl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Backage.ParameterDecl params = 3;
  total_size += 1UL * this->_internal_params_size();
  for (const auto& msg : this->_impl_.params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes block = 5;
  if (!this->_internal_block().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_block());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes lib = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_lib());
    }

    // optional bytes alias = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_alias());
    }

  }
  // uint32 flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
  }

  // uint32 nameToken = 2;
  if (this->_internal_nametoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nametoken());
  }

  // uint32 retTypeToken = 4;
  if (this->_internal_rettypetoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rettypetoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ForeignEntryDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ForeignEntryDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ForeignEntryDecl::GetClassData() const { return &_class_data_; }


void ForeignEntryDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ForeignEntryDecl*>(&to_msg);
  auto& from = static_cast<const ForeignEntryDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.ForeignEntryDecl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.params_.MergeFrom(from._impl_.params_);
  if (!from._internal_block().empty()) {
    _this->_internal_set_block(from._internal_block());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_lib(from._internal_lib());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_alias(from._internal_alias());
    }
  }
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  if (from._internal_nametoken() != 0) {
    _this->_internal_set_nametoken(from._internal_nametoken());
  }
  if (from._internal_rettypetoken() != 0) {
    _this->_internal_set_rettypetoken(from._internal_rettypetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ForeignEntryDecl::CopyFrom(const ForeignEntryDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.ForeignEntryDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForeignEntryDecl::IsInitialized() const {
  return true;
}

void ForeignEntryDecl::InternalSwap(ForeignEntryDecl* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.params_.InternalSwap(&other->_impl_.params_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.block_, lhs_arena,
      &other->_impl_.block_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lib_, lhs_arena,
      &other->_impl_.lib_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.alias_, lhs_arena,
      &other->_impl_.alias_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ForeignEntryDecl, _impl_.rettypetoken_)
      + sizeof(ForeignEntryDecl::_impl_.rettypetoken_)
      - PROTOBUF_FIELD_OFFSET(ForeignEntryDecl, _impl_.flag_)>(
          reinterpret_cast<char*>(&_impl_.flag_),
          reinterpret_cast<char*>(&other->_impl_.flag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ForeignEntryDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[17]);
}

// ===================================================================

class LineNumber::_Internal {
 public:
};

LineNumber::LineNumber(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.LineNumber)
}
LineNumber::LineNumber(const LineNumber& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LineNumber* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.line_){}
    , decltype(_impl_.offset_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.line_, &from._impl_.line_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.offset_) -
    reinterpret_cast<char*>(&_impl_.line_)) + sizeof(_impl_.offset_));
  // @@protoc_insertion_point(copy_constructor:Backage.LineNumber)
}

inline void LineNumber::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.line_){0u}
    , decltype(_impl_.offset_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LineNumber::~LineNumber() {
  // @@protoc_insertion_point(destructor:Backage.LineNumber)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LineNumber::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LineNumber::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LineNumber::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.LineNumber)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.line_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.offset_) -
      reinterpret_cast<char*>(&_impl_.line_)) + sizeof(_impl_.offset_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LineNumber::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 line = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.line_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LineNumber::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.LineNumber)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 line = 1;
  if (this->_internal_line() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_line(), target);
  }

  // uint32 offset = 2;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.LineNumber)
  return target;
}

size_t LineNumber::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.LineNumber)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 line = 1;
  if (this->_internal_line() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_line());
  }

  // uint32 offset = 2;
  if (this->_internal_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_offset());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LineNumber::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LineNumber::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LineNumber::GetClassData() const { return &_class_data_; }


void LineNumber::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LineNumber*>(&to_msg);
  auto& from = static_cast<const LineNumber&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.LineNumber)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_line() != 0) {
    _this->_internal_set_line(from._internal_line());
  }
  if (from._internal_offset() != 0) {
    _this->_internal_set_offset(from._internal_offset());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LineNumber::CopyFrom(const LineNumber& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.LineNumber)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LineNumber::IsInitialized() const {
  return true;
}

void LineNumber::InternalSwap(LineNumber* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LineNumber, _impl_.offset_)
      + sizeof(LineNumber::_impl_.offset_)
      - PROTOBUF_FIELD_OFFSET(LineNumber, _impl_.line_)>(
          reinterpret_cast<char*>(&_impl_.line_),
          reinterpret_cast<char*>(&other->_impl_.line_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LineNumber::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[18]);
}

// ===================================================================

class ExceptionEntry::_Internal {
 public:
};

ExceptionEntry::ExceptionEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Backage.ExceptionEntry)
}
ExceptionEntry::ExceptionEntry(const ExceptionEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExceptionEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.offset_){}
    , decltype(_impl_.length_){}
    , decltype(_impl_.target_){}
    , decltype(_impl_.typetoken_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.offset_, &from._impl_.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.typetoken_) -
    reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.typetoken_));
  // @@protoc_insertion_point(copy_constructor:Backage.ExceptionEntry)
}

inline void ExceptionEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.offset_){0u}
    , decltype(_impl_.length_){0u}
    , decltype(_impl_.target_){0u}
    , decltype(_impl_.typetoken_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ExceptionEntry::~ExceptionEntry() {
  // @@protoc_insertion_point(destructor:Backage.ExceptionEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExceptionEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExceptionEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExceptionEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:Backage.ExceptionEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.offset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.typetoken_) -
      reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.typetoken_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExceptionEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 offset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 target = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 typeToken = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.typetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExceptionEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backage.ExceptionEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 offset = 1;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_offset(), target);
  }

  // uint32 length = 2;
  if (this->_internal_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_length(), target);
  }

  // uint32 target = 3;
  if (this->_internal_target() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_target(), target);
  }

  // uint32 typeToken = 4;
  if (this->_internal_typetoken() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_typetoken(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backage.ExceptionEntry)
  return target;
}

size_t ExceptionEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backage.ExceptionEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 offset = 1;
  if (this->_internal_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_offset());
  }

  // uint32 length = 2;
  if (this->_internal_length() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
  }

  // uint32 target = 3;
  if (this->_internal_target() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target());
  }

  // uint32 typeToken = 4;
  if (this->_internal_typetoken() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_typetoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExceptionEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExceptionEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExceptionEntry::GetClassData() const { return &_class_data_; }


void ExceptionEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExceptionEntry*>(&to_msg);
  auto& from = static_cast<const ExceptionEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Backage.ExceptionEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_offset() != 0) {
    _this->_internal_set_offset(from._internal_offset());
  }
  if (from._internal_length() != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  if (from._internal_target() != 0) {
    _this->_internal_set_target(from._internal_target());
  }
  if (from._internal_typetoken() != 0) {
    _this->_internal_set_typetoken(from._internal_typetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExceptionEntry::CopyFrom(const ExceptionEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backage.ExceptionEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExceptionEntry::IsInitialized() const {
  return true;
}

void ExceptionEntry::InternalSwap(ExceptionEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExceptionEntry, _impl_.typetoken_)
      + sizeof(ExceptionEntry::_impl_.typetoken_)
      - PROTOBUF_FIELD_OFFSET(ExceptionEntry, _impl_.offset_)>(
          reinterpret_cast<char*>(&_impl_.offset_),
          reinterpret_cast<char*>(&other->_impl_.offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExceptionEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backage_2eproto_getter, &descriptor_table_backage_2eproto_once,
      file_level_metadata_backage_2eproto[19]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Backage
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Backage::Dependency*
Arena::CreateMaybeMessage< ::Backage::Dependency >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::Dependency >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::TextToken*
Arena::CreateMaybeMessage< ::Backage::TextToken >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::TextToken >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::ConstructedToken*
Arena::CreateMaybeMessage< ::Backage::ConstructedToken >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::ConstructedToken >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::ArrayToken*
Arena::CreateMaybeMessage< ::Backage::ArrayToken >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::ArrayToken >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::TokenDefinition*
Arena::CreateMaybeMessage< ::Backage::TokenDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::TokenDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::Package*
Arena::CreateMaybeMessage< ::Backage::Package >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::Package >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::Declaration*
Arena::CreateMaybeMessage< ::Backage::Declaration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::Declaration >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::ClassDecl*
Arena::CreateMaybeMessage< ::Backage::ClassDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::ClassDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::RecordDecl*
Arena::CreateMaybeMessage< ::Backage::RecordDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::RecordDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::EnumDecl*
Arena::CreateMaybeMessage< ::Backage::EnumDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::EnumDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::EnumConstant*
Arena::CreateMaybeMessage< ::Backage::EnumConstant >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::EnumConstant >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::VariableDecl*
Arena::CreateMaybeMessage< ::Backage::VariableDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::VariableDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::ParameterDecl*
Arena::CreateMaybeMessage< ::Backage::ParameterDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::ParameterDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::ModuleDecl*
Arena::CreateMaybeMessage< ::Backage::ModuleDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::ModuleDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::LocalIndex*
Arena::CreateMaybeMessage< ::Backage::LocalIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::LocalIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::MethodDecl*
Arena::CreateMaybeMessage< ::Backage::MethodDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::MethodDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::CtorDecl*
Arena::CreateMaybeMessage< ::Backage::CtorDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::CtorDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::ForeignEntryDecl*
Arena::CreateMaybeMessage< ::Backage::ForeignEntryDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::ForeignEntryDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::LineNumber*
Arena::CreateMaybeMessage< ::Backage::LineNumber >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::LineNumber >(arena);
}
template<> PROTOBUF_NOINLINE ::Backage::ExceptionEntry*
Arena::CreateMaybeMessage< ::Backage::ExceptionEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Backage::ExceptionEntry >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
