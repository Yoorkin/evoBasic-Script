// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: backage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_backage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_backage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_backage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_backage_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_backage_2eproto;
namespace Backage {
class ArrayToken;
struct ArrayTokenDefaultTypeInternal;
extern ArrayTokenDefaultTypeInternal _ArrayToken_default_instance_;
class ClassDecl;
struct ClassDeclDefaultTypeInternal;
extern ClassDeclDefaultTypeInternal _ClassDecl_default_instance_;
class ConstructedToken;
struct ConstructedTokenDefaultTypeInternal;
extern ConstructedTokenDefaultTypeInternal _ConstructedToken_default_instance_;
class CtorDecl;
struct CtorDeclDefaultTypeInternal;
extern CtorDeclDefaultTypeInternal _CtorDecl_default_instance_;
class Declaration;
struct DeclarationDefaultTypeInternal;
extern DeclarationDefaultTypeInternal _Declaration_default_instance_;
class Dependency;
struct DependencyDefaultTypeInternal;
extern DependencyDefaultTypeInternal _Dependency_default_instance_;
class EnumConstant;
struct EnumConstantDefaultTypeInternal;
extern EnumConstantDefaultTypeInternal _EnumConstant_default_instance_;
class EnumDecl;
struct EnumDeclDefaultTypeInternal;
extern EnumDeclDefaultTypeInternal _EnumDecl_default_instance_;
class ExceptionEntry;
struct ExceptionEntryDefaultTypeInternal;
extern ExceptionEntryDefaultTypeInternal _ExceptionEntry_default_instance_;
class ForeignEntryDecl;
struct ForeignEntryDeclDefaultTypeInternal;
extern ForeignEntryDeclDefaultTypeInternal _ForeignEntryDecl_default_instance_;
class LineNumber;
struct LineNumberDefaultTypeInternal;
extern LineNumberDefaultTypeInternal _LineNumber_default_instance_;
class LocalIndex;
struct LocalIndexDefaultTypeInternal;
extern LocalIndexDefaultTypeInternal _LocalIndex_default_instance_;
class MethodDecl;
struct MethodDeclDefaultTypeInternal;
extern MethodDeclDefaultTypeInternal _MethodDecl_default_instance_;
class ModuleDecl;
struct ModuleDeclDefaultTypeInternal;
extern ModuleDeclDefaultTypeInternal _ModuleDecl_default_instance_;
class Package;
struct PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class ParameterDecl;
struct ParameterDeclDefaultTypeInternal;
extern ParameterDeclDefaultTypeInternal _ParameterDecl_default_instance_;
class RecordDecl;
struct RecordDeclDefaultTypeInternal;
extern RecordDeclDefaultTypeInternal _RecordDecl_default_instance_;
class TextToken;
struct TextTokenDefaultTypeInternal;
extern TextTokenDefaultTypeInternal _TextToken_default_instance_;
class TokenDefinition;
struct TokenDefinitionDefaultTypeInternal;
extern TokenDefinitionDefaultTypeInternal _TokenDefinition_default_instance_;
class VariableDecl;
struct VariableDeclDefaultTypeInternal;
extern VariableDeclDefaultTypeInternal _VariableDecl_default_instance_;
}  // namespace Backage
PROTOBUF_NAMESPACE_OPEN
template<> ::Backage::ArrayToken* Arena::CreateMaybeMessage<::Backage::ArrayToken>(Arena*);
template<> ::Backage::ClassDecl* Arena::CreateMaybeMessage<::Backage::ClassDecl>(Arena*);
template<> ::Backage::ConstructedToken* Arena::CreateMaybeMessage<::Backage::ConstructedToken>(Arena*);
template<> ::Backage::CtorDecl* Arena::CreateMaybeMessage<::Backage::CtorDecl>(Arena*);
template<> ::Backage::Declaration* Arena::CreateMaybeMessage<::Backage::Declaration>(Arena*);
template<> ::Backage::Dependency* Arena::CreateMaybeMessage<::Backage::Dependency>(Arena*);
template<> ::Backage::EnumConstant* Arena::CreateMaybeMessage<::Backage::EnumConstant>(Arena*);
template<> ::Backage::EnumDecl* Arena::CreateMaybeMessage<::Backage::EnumDecl>(Arena*);
template<> ::Backage::ExceptionEntry* Arena::CreateMaybeMessage<::Backage::ExceptionEntry>(Arena*);
template<> ::Backage::ForeignEntryDecl* Arena::CreateMaybeMessage<::Backage::ForeignEntryDecl>(Arena*);
template<> ::Backage::LineNumber* Arena::CreateMaybeMessage<::Backage::LineNumber>(Arena*);
template<> ::Backage::LocalIndex* Arena::CreateMaybeMessage<::Backage::LocalIndex>(Arena*);
template<> ::Backage::MethodDecl* Arena::CreateMaybeMessage<::Backage::MethodDecl>(Arena*);
template<> ::Backage::ModuleDecl* Arena::CreateMaybeMessage<::Backage::ModuleDecl>(Arena*);
template<> ::Backage::Package* Arena::CreateMaybeMessage<::Backage::Package>(Arena*);
template<> ::Backage::ParameterDecl* Arena::CreateMaybeMessage<::Backage::ParameterDecl>(Arena*);
template<> ::Backage::RecordDecl* Arena::CreateMaybeMessage<::Backage::RecordDecl>(Arena*);
template<> ::Backage::TextToken* Arena::CreateMaybeMessage<::Backage::TextToken>(Arena*);
template<> ::Backage::TokenDefinition* Arena::CreateMaybeMessage<::Backage::TokenDefinition>(Arena*);
template<> ::Backage::VariableDecl* Arena::CreateMaybeMessage<::Backage::VariableDecl>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Backage {

// ===================================================================

class Dependency final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.Dependency) */ {
 public:
  inline Dependency() : Dependency(nullptr) {}
  ~Dependency() override;
  explicit PROTOBUF_CONSTEXPR Dependency(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dependency(const Dependency& from);
  Dependency(Dependency&& from) noexcept
    : Dependency() {
    *this = ::std::move(from);
  }

  inline Dependency& operator=(const Dependency& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dependency& operator=(Dependency&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dependency& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dependency* internal_default_instance() {
    return reinterpret_cast<const Dependency*>(
               &_Dependency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Dependency& a, Dependency& b) {
    a.Swap(&b);
  }
  inline void Swap(Dependency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dependency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dependency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dependency>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dependency& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dependency& from) {
    Dependency::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dependency* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.Dependency";
  }
  protected:
  explicit Dependency(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:Backage.Dependency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class TextToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.TextToken) */ {
 public:
  inline TextToken() : TextToken(nullptr) {}
  ~TextToken() override;
  explicit PROTOBUF_CONSTEXPR TextToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextToken(const TextToken& from);
  TextToken(TextToken&& from) noexcept
    : TextToken() {
    *this = ::std::move(from);
  }

  inline TextToken& operator=(const TextToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextToken& operator=(TextToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextToken* internal_default_instance() {
    return reinterpret_cast<const TextToken*>(
               &_TextToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TextToken& a, TextToken& b) {
    a.Swap(&b);
  }
  inline void Swap(TextToken* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextToken& from) {
    TextToken::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextToken* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.TextToken";
  }
  protected:
  explicit TextToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:Backage.TextToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class ConstructedToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.ConstructedToken) */ {
 public:
  inline ConstructedToken() : ConstructedToken(nullptr) {}
  ~ConstructedToken() override;
  explicit PROTOBUF_CONSTEXPR ConstructedToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstructedToken(const ConstructedToken& from);
  ConstructedToken(ConstructedToken&& from) noexcept
    : ConstructedToken() {
    *this = ::std::move(from);
  }

  inline ConstructedToken& operator=(const ConstructedToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstructedToken& operator=(ConstructedToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstructedToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstructedToken* internal_default_instance() {
    return reinterpret_cast<const ConstructedToken*>(
               &_ConstructedToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConstructedToken& a, ConstructedToken& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstructedToken* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstructedToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstructedToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstructedToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstructedToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConstructedToken& from) {
    ConstructedToken::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstructedToken* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.ConstructedToken";
  }
  protected:
  explicit ConstructedToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 1,
  };
  // repeated uint32 tokens = 1;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  private:
  uint32_t _internal_tokens(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_tokens() const;
  void _internal_add_tokens(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_tokens();
  public:
  uint32_t tokens(int index) const;
  void set_tokens(int index, uint32_t value);
  void add_tokens(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      tokens() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_tokens();

  // @@protoc_insertion_point(class_scope:Backage.ConstructedToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > tokens_;
    mutable std::atomic<int> _tokens_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class ArrayToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.ArrayToken) */ {
 public:
  inline ArrayToken() : ArrayToken(nullptr) {}
  ~ArrayToken() override;
  explicit PROTOBUF_CONSTEXPR ArrayToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArrayToken(const ArrayToken& from);
  ArrayToken(ArrayToken&& from) noexcept
    : ArrayToken() {
    *this = ::std::move(from);
  }

  inline ArrayToken& operator=(const ArrayToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayToken& operator=(ArrayToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArrayToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArrayToken* internal_default_instance() {
    return reinterpret_cast<const ArrayToken*>(
               &_ArrayToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ArrayToken& a, ArrayToken& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayToken* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrayToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrayToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArrayToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArrayToken& from) {
    ArrayToken::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArrayToken* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.ArrayToken";
  }
  protected:
  explicit ArrayToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeTokenFieldNumber = 1,
  };
  // uint32 typeToken = 1;
  void clear_typetoken();
  uint32_t typetoken() const;
  void set_typetoken(uint32_t value);
  private:
  uint32_t _internal_typetoken() const;
  void _internal_set_typetoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.ArrayToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t typetoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class TokenDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.TokenDefinition) */ {
 public:
  inline TokenDefinition() : TokenDefinition(nullptr) {}
  ~TokenDefinition() override;
  explicit PROTOBUF_CONSTEXPR TokenDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenDefinition(const TokenDefinition& from);
  TokenDefinition(TokenDefinition&& from) noexcept
    : TokenDefinition() {
    *this = ::std::move(from);
  }

  inline TokenDefinition& operator=(const TokenDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenDefinition& operator=(TokenDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenDefinition& default_instance() {
    return *internal_default_instance();
  }
  enum DefinitionCase {
    kTextToken = 2,
    kConstructedToken = 3,
    kArrayToken = 4,
    DEFINITION_NOT_SET = 0,
  };

  static inline const TokenDefinition* internal_default_instance() {
    return reinterpret_cast<const TokenDefinition*>(
               &_TokenDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TokenDefinition& a, TokenDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenDefinition& from) {
    TokenDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.TokenDefinition";
  }
  protected:
  explicit TokenDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTextTokenFieldNumber = 2,
    kConstructedTokenFieldNumber = 3,
    kArrayTokenFieldNumber = 4,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // .Backage.TextToken textToken = 2;
  bool has_texttoken() const;
  private:
  bool _internal_has_texttoken() const;
  public:
  void clear_texttoken();
  const ::Backage::TextToken& texttoken() const;
  PROTOBUF_NODISCARD ::Backage::TextToken* release_texttoken();
  ::Backage::TextToken* mutable_texttoken();
  void set_allocated_texttoken(::Backage::TextToken* texttoken);
  private:
  const ::Backage::TextToken& _internal_texttoken() const;
  ::Backage::TextToken* _internal_mutable_texttoken();
  public:
  void unsafe_arena_set_allocated_texttoken(
      ::Backage::TextToken* texttoken);
  ::Backage::TextToken* unsafe_arena_release_texttoken();

  // .Backage.ConstructedToken constructedToken = 3;
  bool has_constructedtoken() const;
  private:
  bool _internal_has_constructedtoken() const;
  public:
  void clear_constructedtoken();
  const ::Backage::ConstructedToken& constructedtoken() const;
  PROTOBUF_NODISCARD ::Backage::ConstructedToken* release_constructedtoken();
  ::Backage::ConstructedToken* mutable_constructedtoken();
  void set_allocated_constructedtoken(::Backage::ConstructedToken* constructedtoken);
  private:
  const ::Backage::ConstructedToken& _internal_constructedtoken() const;
  ::Backage::ConstructedToken* _internal_mutable_constructedtoken();
  public:
  void unsafe_arena_set_allocated_constructedtoken(
      ::Backage::ConstructedToken* constructedtoken);
  ::Backage::ConstructedToken* unsafe_arena_release_constructedtoken();

  // .Backage.ArrayToken arrayToken = 4;
  bool has_arraytoken() const;
  private:
  bool _internal_has_arraytoken() const;
  public:
  void clear_arraytoken();
  const ::Backage::ArrayToken& arraytoken() const;
  PROTOBUF_NODISCARD ::Backage::ArrayToken* release_arraytoken();
  ::Backage::ArrayToken* mutable_arraytoken();
  void set_allocated_arraytoken(::Backage::ArrayToken* arraytoken);
  private:
  const ::Backage::ArrayToken& _internal_arraytoken() const;
  ::Backage::ArrayToken* _internal_mutable_arraytoken();
  public:
  void unsafe_arena_set_allocated_arraytoken(
      ::Backage::ArrayToken* arraytoken);
  ::Backage::ArrayToken* unsafe_arena_release_arraytoken();

  void clear_definition();
  DefinitionCase definition_case() const;
  // @@protoc_insertion_point(class_scope:Backage.TokenDefinition)
 private:
  class _Internal;
  void set_has_texttoken();
  void set_has_constructedtoken();
  void set_has_arraytoken();

  inline bool has_definition() const;
  inline void clear_has_definition();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    union DefinitionUnion {
      constexpr DefinitionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Backage::TextToken* texttoken_;
      ::Backage::ConstructedToken* constructedtoken_;
      ::Backage::ArrayToken* arraytoken_;
    } definition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class Package final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.Package) */ {
 public:
  inline Package() : Package(nullptr) {}
  ~Package() override;
  explicit PROTOBUF_CONSTEXPR Package(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Package(const Package& from);
  Package(Package&& from) noexcept
    : Package() {
    *this = ::std::move(from);
  }

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }
  inline Package& operator=(Package&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Package& default_instance() {
    return *internal_default_instance();
  }
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
               &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Package& a, Package& b) {
    a.Swap(&b);
  }
  inline void Swap(Package* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Package* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Package>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Package& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Package& from) {
    Package::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Package* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.Package";
  }
  protected:
  explicit Package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDependenciesFieldNumber = 1,
    kTokensFieldNumber = 2,
    kDeclarationsFieldNumber = 3,
    kIdentityFieldNumber = 4,
    kVersionFieldNumber = 5,
  };
  // repeated .Backage.Dependency dependencies = 1;
  int dependencies_size() const;
  private:
  int _internal_dependencies_size() const;
  public:
  void clear_dependencies();
  ::Backage::Dependency* mutable_dependencies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Dependency >*
      mutable_dependencies();
  private:
  const ::Backage::Dependency& _internal_dependencies(int index) const;
  ::Backage::Dependency* _internal_add_dependencies();
  public:
  const ::Backage::Dependency& dependencies(int index) const;
  ::Backage::Dependency* add_dependencies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Dependency >&
      dependencies() const;

  // repeated .Backage.TokenDefinition tokens = 2;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  ::Backage::TokenDefinition* mutable_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::TokenDefinition >*
      mutable_tokens();
  private:
  const ::Backage::TokenDefinition& _internal_tokens(int index) const;
  ::Backage::TokenDefinition* _internal_add_tokens();
  public:
  const ::Backage::TokenDefinition& tokens(int index) const;
  ::Backage::TokenDefinition* add_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::TokenDefinition >&
      tokens() const;

  // repeated .Backage.Declaration declarations = 3;
  int declarations_size() const;
  private:
  int _internal_declarations_size() const;
  public:
  void clear_declarations();
  ::Backage::Declaration* mutable_declarations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >*
      mutable_declarations();
  private:
  const ::Backage::Declaration& _internal_declarations(int index) const;
  ::Backage::Declaration* _internal_add_declarations();
  public:
  const ::Backage::Declaration& declarations(int index) const;
  ::Backage::Declaration* add_declarations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >&
      declarations() const;

  // string identity = 4;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // uint64 version = 5;
  void clear_version();
  uint64_t version() const;
  void set_version(uint64_t value);
  private:
  uint64_t _internal_version() const;
  void _internal_set_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.Package)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Dependency > dependencies_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::TokenDefinition > tokens_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration > declarations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    uint64_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class Declaration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.Declaration) */ {
 public:
  inline Declaration() : Declaration(nullptr) {}
  ~Declaration() override;
  explicit PROTOBUF_CONSTEXPR Declaration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Declaration(const Declaration& from);
  Declaration(Declaration&& from) noexcept
    : Declaration() {
    *this = ::std::move(from);
  }

  inline Declaration& operator=(const Declaration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Declaration& operator=(Declaration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Declaration& default_instance() {
    return *internal_default_instance();
  }
  enum MemberCase {
    kClassDecl = 1,
    kRecordDecl = 2,
    kEnumDecl = 3,
    kEnumConstant = 4,
    kVaraibleDecl = 5,
    kModuleDecl = 6,
    kMethodDecl = 7,
    kCtorDecl = 8,
    kForeignEntryDecl = 9,
    MEMBER_NOT_SET = 0,
  };

  static inline const Declaration* internal_default_instance() {
    return reinterpret_cast<const Declaration*>(
               &_Declaration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Declaration& a, Declaration& b) {
    a.Swap(&b);
  }
  inline void Swap(Declaration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Declaration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Declaration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Declaration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Declaration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Declaration& from) {
    Declaration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Declaration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.Declaration";
  }
  protected:
  explicit Declaration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassDeclFieldNumber = 1,
    kRecordDeclFieldNumber = 2,
    kEnumDeclFieldNumber = 3,
    kEnumConstantFieldNumber = 4,
    kVaraibleDeclFieldNumber = 5,
    kModuleDeclFieldNumber = 6,
    kMethodDeclFieldNumber = 7,
    kCtorDeclFieldNumber = 8,
    kForeignEntryDeclFieldNumber = 9,
  };
  // .Backage.ClassDecl classDecl = 1;
  bool has_classdecl() const;
  private:
  bool _internal_has_classdecl() const;
  public:
  void clear_classdecl();
  const ::Backage::ClassDecl& classdecl() const;
  PROTOBUF_NODISCARD ::Backage::ClassDecl* release_classdecl();
  ::Backage::ClassDecl* mutable_classdecl();
  void set_allocated_classdecl(::Backage::ClassDecl* classdecl);
  private:
  const ::Backage::ClassDecl& _internal_classdecl() const;
  ::Backage::ClassDecl* _internal_mutable_classdecl();
  public:
  void unsafe_arena_set_allocated_classdecl(
      ::Backage::ClassDecl* classdecl);
  ::Backage::ClassDecl* unsafe_arena_release_classdecl();

  // .Backage.RecordDecl recordDecl = 2;
  bool has_recorddecl() const;
  private:
  bool _internal_has_recorddecl() const;
  public:
  void clear_recorddecl();
  const ::Backage::RecordDecl& recorddecl() const;
  PROTOBUF_NODISCARD ::Backage::RecordDecl* release_recorddecl();
  ::Backage::RecordDecl* mutable_recorddecl();
  void set_allocated_recorddecl(::Backage::RecordDecl* recorddecl);
  private:
  const ::Backage::RecordDecl& _internal_recorddecl() const;
  ::Backage::RecordDecl* _internal_mutable_recorddecl();
  public:
  void unsafe_arena_set_allocated_recorddecl(
      ::Backage::RecordDecl* recorddecl);
  ::Backage::RecordDecl* unsafe_arena_release_recorddecl();

  // .Backage.EnumDecl enumDecl = 3;
  bool has_enumdecl() const;
  private:
  bool _internal_has_enumdecl() const;
  public:
  void clear_enumdecl();
  const ::Backage::EnumDecl& enumdecl() const;
  PROTOBUF_NODISCARD ::Backage::EnumDecl* release_enumdecl();
  ::Backage::EnumDecl* mutable_enumdecl();
  void set_allocated_enumdecl(::Backage::EnumDecl* enumdecl);
  private:
  const ::Backage::EnumDecl& _internal_enumdecl() const;
  ::Backage::EnumDecl* _internal_mutable_enumdecl();
  public:
  void unsafe_arena_set_allocated_enumdecl(
      ::Backage::EnumDecl* enumdecl);
  ::Backage::EnumDecl* unsafe_arena_release_enumdecl();

  // .Backage.EnumConstant enumConstant = 4;
  bool has_enumconstant() const;
  private:
  bool _internal_has_enumconstant() const;
  public:
  void clear_enumconstant();
  const ::Backage::EnumConstant& enumconstant() const;
  PROTOBUF_NODISCARD ::Backage::EnumConstant* release_enumconstant();
  ::Backage::EnumConstant* mutable_enumconstant();
  void set_allocated_enumconstant(::Backage::EnumConstant* enumconstant);
  private:
  const ::Backage::EnumConstant& _internal_enumconstant() const;
  ::Backage::EnumConstant* _internal_mutable_enumconstant();
  public:
  void unsafe_arena_set_allocated_enumconstant(
      ::Backage::EnumConstant* enumconstant);
  ::Backage::EnumConstant* unsafe_arena_release_enumconstant();

  // .Backage.VariableDecl varaibleDecl = 5;
  bool has_varaibledecl() const;
  private:
  bool _internal_has_varaibledecl() const;
  public:
  void clear_varaibledecl();
  const ::Backage::VariableDecl& varaibledecl() const;
  PROTOBUF_NODISCARD ::Backage::VariableDecl* release_varaibledecl();
  ::Backage::VariableDecl* mutable_varaibledecl();
  void set_allocated_varaibledecl(::Backage::VariableDecl* varaibledecl);
  private:
  const ::Backage::VariableDecl& _internal_varaibledecl() const;
  ::Backage::VariableDecl* _internal_mutable_varaibledecl();
  public:
  void unsafe_arena_set_allocated_varaibledecl(
      ::Backage::VariableDecl* varaibledecl);
  ::Backage::VariableDecl* unsafe_arena_release_varaibledecl();

  // .Backage.ModuleDecl moduleDecl = 6;
  bool has_moduledecl() const;
  private:
  bool _internal_has_moduledecl() const;
  public:
  void clear_moduledecl();
  const ::Backage::ModuleDecl& moduledecl() const;
  PROTOBUF_NODISCARD ::Backage::ModuleDecl* release_moduledecl();
  ::Backage::ModuleDecl* mutable_moduledecl();
  void set_allocated_moduledecl(::Backage::ModuleDecl* moduledecl);
  private:
  const ::Backage::ModuleDecl& _internal_moduledecl() const;
  ::Backage::ModuleDecl* _internal_mutable_moduledecl();
  public:
  void unsafe_arena_set_allocated_moduledecl(
      ::Backage::ModuleDecl* moduledecl);
  ::Backage::ModuleDecl* unsafe_arena_release_moduledecl();

  // .Backage.MethodDecl methodDecl = 7;
  bool has_methoddecl() const;
  private:
  bool _internal_has_methoddecl() const;
  public:
  void clear_methoddecl();
  const ::Backage::MethodDecl& methoddecl() const;
  PROTOBUF_NODISCARD ::Backage::MethodDecl* release_methoddecl();
  ::Backage::MethodDecl* mutable_methoddecl();
  void set_allocated_methoddecl(::Backage::MethodDecl* methoddecl);
  private:
  const ::Backage::MethodDecl& _internal_methoddecl() const;
  ::Backage::MethodDecl* _internal_mutable_methoddecl();
  public:
  void unsafe_arena_set_allocated_methoddecl(
      ::Backage::MethodDecl* methoddecl);
  ::Backage::MethodDecl* unsafe_arena_release_methoddecl();

  // .Backage.CtorDecl ctorDecl = 8;
  bool has_ctordecl() const;
  private:
  bool _internal_has_ctordecl() const;
  public:
  void clear_ctordecl();
  const ::Backage::CtorDecl& ctordecl() const;
  PROTOBUF_NODISCARD ::Backage::CtorDecl* release_ctordecl();
  ::Backage::CtorDecl* mutable_ctordecl();
  void set_allocated_ctordecl(::Backage::CtorDecl* ctordecl);
  private:
  const ::Backage::CtorDecl& _internal_ctordecl() const;
  ::Backage::CtorDecl* _internal_mutable_ctordecl();
  public:
  void unsafe_arena_set_allocated_ctordecl(
      ::Backage::CtorDecl* ctordecl);
  ::Backage::CtorDecl* unsafe_arena_release_ctordecl();

  // .Backage.ForeignEntryDecl foreignEntryDecl = 9;
  bool has_foreignentrydecl() const;
  private:
  bool _internal_has_foreignentrydecl() const;
  public:
  void clear_foreignentrydecl();
  const ::Backage::ForeignEntryDecl& foreignentrydecl() const;
  PROTOBUF_NODISCARD ::Backage::ForeignEntryDecl* release_foreignentrydecl();
  ::Backage::ForeignEntryDecl* mutable_foreignentrydecl();
  void set_allocated_foreignentrydecl(::Backage::ForeignEntryDecl* foreignentrydecl);
  private:
  const ::Backage::ForeignEntryDecl& _internal_foreignentrydecl() const;
  ::Backage::ForeignEntryDecl* _internal_mutable_foreignentrydecl();
  public:
  void unsafe_arena_set_allocated_foreignentrydecl(
      ::Backage::ForeignEntryDecl* foreignentrydecl);
  ::Backage::ForeignEntryDecl* unsafe_arena_release_foreignentrydecl();

  void clear_Member();
  MemberCase Member_case() const;
  // @@protoc_insertion_point(class_scope:Backage.Declaration)
 private:
  class _Internal;
  void set_has_classdecl();
  void set_has_recorddecl();
  void set_has_enumdecl();
  void set_has_enumconstant();
  void set_has_varaibledecl();
  void set_has_moduledecl();
  void set_has_methoddecl();
  void set_has_ctordecl();
  void set_has_foreignentrydecl();

  inline bool has_Member() const;
  inline void clear_has_Member();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MemberUnion {
      constexpr MemberUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Backage::ClassDecl* classdecl_;
      ::Backage::RecordDecl* recorddecl_;
      ::Backage::EnumDecl* enumdecl_;
      ::Backage::EnumConstant* enumconstant_;
      ::Backage::VariableDecl* varaibledecl_;
      ::Backage::ModuleDecl* moduledecl_;
      ::Backage::MethodDecl* methoddecl_;
      ::Backage::CtorDecl* ctordecl_;
      ::Backage::ForeignEntryDecl* foreignentrydecl_;
    } Member_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class ClassDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.ClassDecl) */ {
 public:
  inline ClassDecl() : ClassDecl(nullptr) {}
  ~ClassDecl() override;
  explicit PROTOBUF_CONSTEXPR ClassDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClassDecl(const ClassDecl& from);
  ClassDecl(ClassDecl&& from) noexcept
    : ClassDecl() {
    *this = ::std::move(from);
  }

  inline ClassDecl& operator=(const ClassDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassDecl& operator=(ClassDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassDecl& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClassDecl* internal_default_instance() {
    return reinterpret_cast<const ClassDecl*>(
               &_ClassDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClassDecl& a, ClassDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(ClassDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassDecl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClassDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClassDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClassDecl& from) {
    ClassDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.ClassDecl";
  }
  protected:
  explicit ClassDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImplTokenFieldNumber = 4,
    kDeclarationsFieldNumber = 5,
    kFlagFieldNumber = 1,
    kNameTokenFieldNumber = 2,
    kBaseTokenFieldNumber = 3,
  };
  // repeated uint32 implToken = 4;
  int impltoken_size() const;
  private:
  int _internal_impltoken_size() const;
  public:
  void clear_impltoken();
  private:
  uint32_t _internal_impltoken(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_impltoken() const;
  void _internal_add_impltoken(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_impltoken();
  public:
  uint32_t impltoken(int index) const;
  void set_impltoken(int index, uint32_t value);
  void add_impltoken(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      impltoken() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_impltoken();

  // repeated .Backage.Declaration declarations = 5;
  int declarations_size() const;
  private:
  int _internal_declarations_size() const;
  public:
  void clear_declarations();
  ::Backage::Declaration* mutable_declarations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >*
      mutable_declarations();
  private:
  const ::Backage::Declaration& _internal_declarations(int index) const;
  ::Backage::Declaration* _internal_add_declarations();
  public:
  const ::Backage::Declaration& declarations(int index) const;
  ::Backage::Declaration* add_declarations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >&
      declarations() const;

  // uint32 flag = 1;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // uint32 nameToken = 2;
  void clear_nametoken();
  uint32_t nametoken() const;
  void set_nametoken(uint32_t value);
  private:
  uint32_t _internal_nametoken() const;
  void _internal_set_nametoken(uint32_t value);
  public:

  // uint32 baseToken = 3;
  void clear_basetoken();
  uint32_t basetoken() const;
  void set_basetoken(uint32_t value);
  private:
  uint32_t _internal_basetoken() const;
  void _internal_set_basetoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.ClassDecl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > impltoken_;
    mutable std::atomic<int> _impltoken_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration > declarations_;
    uint32_t flag_;
    uint32_t nametoken_;
    uint32_t basetoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class RecordDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.RecordDecl) */ {
 public:
  inline RecordDecl() : RecordDecl(nullptr) {}
  ~RecordDecl() override;
  explicit PROTOBUF_CONSTEXPR RecordDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordDecl(const RecordDecl& from);
  RecordDecl(RecordDecl&& from) noexcept
    : RecordDecl() {
    *this = ::std::move(from);
  }

  inline RecordDecl& operator=(const RecordDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordDecl& operator=(RecordDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordDecl& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordDecl* internal_default_instance() {
    return reinterpret_cast<const RecordDecl*>(
               &_RecordDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RecordDecl& a, RecordDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordDecl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordDecl& from) {
    RecordDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.RecordDecl";
  }
  protected:
  explicit RecordDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeclarationsFieldNumber = 3,
    kFlagFieldNumber = 1,
    kNameTokenFieldNumber = 2,
  };
  // repeated .Backage.Declaration declarations = 3;
  int declarations_size() const;
  private:
  int _internal_declarations_size() const;
  public:
  void clear_declarations();
  ::Backage::Declaration* mutable_declarations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >*
      mutable_declarations();
  private:
  const ::Backage::Declaration& _internal_declarations(int index) const;
  ::Backage::Declaration* _internal_add_declarations();
  public:
  const ::Backage::Declaration& declarations(int index) const;
  ::Backage::Declaration* add_declarations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >&
      declarations() const;

  // uint32 flag = 1;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // uint32 nameToken = 2;
  void clear_nametoken();
  uint32_t nametoken() const;
  void set_nametoken(uint32_t value);
  private:
  uint32_t _internal_nametoken() const;
  void _internal_set_nametoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.RecordDecl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration > declarations_;
    uint32_t flag_;
    uint32_t nametoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class EnumDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.EnumDecl) */ {
 public:
  inline EnumDecl() : EnumDecl(nullptr) {}
  ~EnumDecl() override;
  explicit PROTOBUF_CONSTEXPR EnumDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnumDecl(const EnumDecl& from);
  EnumDecl(EnumDecl&& from) noexcept
    : EnumDecl() {
    *this = ::std::move(from);
  }

  inline EnumDecl& operator=(const EnumDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumDecl& operator=(EnumDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumDecl& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnumDecl* internal_default_instance() {
    return reinterpret_cast<const EnumDecl*>(
               &_EnumDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EnumDecl& a, EnumDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(EnumDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumDecl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnumDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnumDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnumDecl& from) {
    EnumDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.EnumDecl";
  }
  protected:
  explicit EnumDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstantsFieldNumber = 3,
    kFlagFieldNumber = 1,
    kNameTokenFieldNumber = 2,
  };
  // repeated .Backage.EnumConstant constants = 3;
  int constants_size() const;
  private:
  int _internal_constants_size() const;
  public:
  void clear_constants();
  ::Backage::EnumConstant* mutable_constants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::EnumConstant >*
      mutable_constants();
  private:
  const ::Backage::EnumConstant& _internal_constants(int index) const;
  ::Backage::EnumConstant* _internal_add_constants();
  public:
  const ::Backage::EnumConstant& constants(int index) const;
  ::Backage::EnumConstant* add_constants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::EnumConstant >&
      constants() const;

  // uint32 flag = 1;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // uint32 nameToken = 2;
  void clear_nametoken();
  uint32_t nametoken() const;
  void set_nametoken(uint32_t value);
  private:
  uint32_t _internal_nametoken() const;
  void _internal_set_nametoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.EnumDecl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::EnumConstant > constants_;
    uint32_t flag_;
    uint32_t nametoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class EnumConstant final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.EnumConstant) */ {
 public:
  inline EnumConstant() : EnumConstant(nullptr) {}
  ~EnumConstant() override;
  explicit PROTOBUF_CONSTEXPR EnumConstant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnumConstant(const EnumConstant& from);
  EnumConstant(EnumConstant&& from) noexcept
    : EnumConstant() {
    *this = ::std::move(from);
  }

  inline EnumConstant& operator=(const EnumConstant& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumConstant& operator=(EnumConstant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumConstant& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnumConstant* internal_default_instance() {
    return reinterpret_cast<const EnumConstant*>(
               &_EnumConstant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EnumConstant& a, EnumConstant& b) {
    a.Swap(&b);
  }
  inline void Swap(EnumConstant* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumConstant* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumConstant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnumConstant>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnumConstant& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnumConstant& from) {
    EnumConstant::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumConstant* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.EnumConstant";
  }
  protected:
  explicit EnumConstant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameTokenFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // uint32 nameToken = 1;
  void clear_nametoken();
  uint32_t nametoken() const;
  void set_nametoken(uint32_t value);
  private:
  uint32_t _internal_nametoken() const;
  void _internal_set_nametoken(uint32_t value);
  public:

  // uint32 value = 2;
  void clear_value();
  uint32_t value() const;
  void set_value(uint32_t value);
  private:
  uint32_t _internal_value() const;
  void _internal_set_value(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.EnumConstant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t nametoken_;
    uint32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class VariableDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.VariableDecl) */ {
 public:
  inline VariableDecl() : VariableDecl(nullptr) {}
  ~VariableDecl() override;
  explicit PROTOBUF_CONSTEXPR VariableDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VariableDecl(const VariableDecl& from);
  VariableDecl(VariableDecl&& from) noexcept
    : VariableDecl() {
    *this = ::std::move(from);
  }

  inline VariableDecl& operator=(const VariableDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline VariableDecl& operator=(VariableDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VariableDecl& default_instance() {
    return *internal_default_instance();
  }
  static inline const VariableDecl* internal_default_instance() {
    return reinterpret_cast<const VariableDecl*>(
               &_VariableDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VariableDecl& a, VariableDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(VariableDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VariableDecl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VariableDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VariableDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VariableDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VariableDecl& from) {
    VariableDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VariableDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.VariableDecl";
  }
  protected:
  explicit VariableDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitialFieldNumber = 4,
    kFlagFieldNumber = 1,
    kNameTokenFieldNumber = 2,
    kTypeTokenFieldNumber = 3,
  };
  // optional bytes initial = 4;
  bool has_initial() const;
  private:
  bool _internal_has_initial() const;
  public:
  void clear_initial();
  const std::string& initial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial();
  PROTOBUF_NODISCARD std::string* release_initial();
  void set_allocated_initial(std::string* initial);
  private:
  const std::string& _internal_initial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial(const std::string& value);
  std::string* _internal_mutable_initial();
  public:

  // uint32 flag = 1;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // uint32 nameToken = 2;
  void clear_nametoken();
  uint32_t nametoken() const;
  void set_nametoken(uint32_t value);
  private:
  uint32_t _internal_nametoken() const;
  void _internal_set_nametoken(uint32_t value);
  public:

  // uint32 typeToken = 3;
  void clear_typetoken();
  uint32_t typetoken() const;
  void set_typetoken(uint32_t value);
  private:
  uint32_t _internal_typetoken() const;
  void _internal_set_typetoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.VariableDecl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_;
    uint32_t flag_;
    uint32_t nametoken_;
    uint32_t typetoken_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class ParameterDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.ParameterDecl) */ {
 public:
  inline ParameterDecl() : ParameterDecl(nullptr) {}
  ~ParameterDecl() override;
  explicit PROTOBUF_CONSTEXPR ParameterDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParameterDecl(const ParameterDecl& from);
  ParameterDecl(ParameterDecl&& from) noexcept
    : ParameterDecl() {
    *this = ::std::move(from);
  }

  inline ParameterDecl& operator=(const ParameterDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParameterDecl& operator=(ParameterDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParameterDecl& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParameterDecl* internal_default_instance() {
    return reinterpret_cast<const ParameterDecl*>(
               &_ParameterDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ParameterDecl& a, ParameterDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(ParameterDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParameterDecl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParameterDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParameterDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParameterDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParameterDecl& from) {
    ParameterDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParameterDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.ParameterDecl";
  }
  protected:
  explicit ParameterDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitialFieldNumber = 4,
    kFlagFieldNumber = 1,
    kNameTokenFieldNumber = 2,
    kTypeTokenFieldNumber = 3,
  };
  // optional bytes initial = 4;
  bool has_initial() const;
  private:
  bool _internal_has_initial() const;
  public:
  void clear_initial();
  const std::string& initial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial();
  PROTOBUF_NODISCARD std::string* release_initial();
  void set_allocated_initial(std::string* initial);
  private:
  const std::string& _internal_initial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial(const std::string& value);
  std::string* _internal_mutable_initial();
  public:

  // uint32 flag = 1;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // uint32 nameToken = 2;
  void clear_nametoken();
  uint32_t nametoken() const;
  void set_nametoken(uint32_t value);
  private:
  uint32_t _internal_nametoken() const;
  void _internal_set_nametoken(uint32_t value);
  public:

  // uint32 typeToken = 3;
  void clear_typetoken();
  uint32_t typetoken() const;
  void set_typetoken(uint32_t value);
  private:
  uint32_t _internal_typetoken() const;
  void _internal_set_typetoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.ParameterDecl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_;
    uint32_t flag_;
    uint32_t nametoken_;
    uint32_t typetoken_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class ModuleDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.ModuleDecl) */ {
 public:
  inline ModuleDecl() : ModuleDecl(nullptr) {}
  ~ModuleDecl() override;
  explicit PROTOBUF_CONSTEXPR ModuleDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleDecl(const ModuleDecl& from);
  ModuleDecl(ModuleDecl&& from) noexcept
    : ModuleDecl() {
    *this = ::std::move(from);
  }

  inline ModuleDecl& operator=(const ModuleDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleDecl& operator=(ModuleDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleDecl& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleDecl* internal_default_instance() {
    return reinterpret_cast<const ModuleDecl*>(
               &_ModuleDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ModuleDecl& a, ModuleDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleDecl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleDecl& from) {
    ModuleDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.ModuleDecl";
  }
  protected:
  explicit ModuleDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeclarationsFieldNumber = 3,
    kFlagFieldNumber = 1,
    kNameTokenFieldNumber = 2,
  };
  // repeated .Backage.Declaration declarations = 3;
  int declarations_size() const;
  private:
  int _internal_declarations_size() const;
  public:
  void clear_declarations();
  ::Backage::Declaration* mutable_declarations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >*
      mutable_declarations();
  private:
  const ::Backage::Declaration& _internal_declarations(int index) const;
  ::Backage::Declaration* _internal_add_declarations();
  public:
  const ::Backage::Declaration& declarations(int index) const;
  ::Backage::Declaration* add_declarations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >&
      declarations() const;

  // uint32 flag = 1;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // uint32 nameToken = 2;
  void clear_nametoken();
  uint32_t nametoken() const;
  void set_nametoken(uint32_t value);
  private:
  uint32_t _internal_nametoken() const;
  void _internal_set_nametoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.ModuleDecl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration > declarations_;
    uint32_t flag_;
    uint32_t nametoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class LocalIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.LocalIndex) */ {
 public:
  inline LocalIndex() : LocalIndex(nullptr) {}
  ~LocalIndex() override;
  explicit PROTOBUF_CONSTEXPR LocalIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalIndex(const LocalIndex& from);
  LocalIndex(LocalIndex&& from) noexcept
    : LocalIndex() {
    *this = ::std::move(from);
  }

  inline LocalIndex& operator=(const LocalIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalIndex& operator=(LocalIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalIndex* internal_default_instance() {
    return reinterpret_cast<const LocalIndex*>(
               &_LocalIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LocalIndex& a, LocalIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalIndex& from) {
    LocalIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.LocalIndex";
  }
  protected:
  explicit LocalIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTypeTokenFieldNumber = 2,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 typeToken = 2;
  void clear_typetoken();
  uint32_t typetoken() const;
  void set_typetoken(uint32_t value);
  private:
  uint32_t _internal_typetoken() const;
  void _internal_set_typetoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.LocalIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t typetoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class MethodDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.MethodDecl) */ {
 public:
  inline MethodDecl() : MethodDecl(nullptr) {}
  ~MethodDecl() override;
  explicit PROTOBUF_CONSTEXPR MethodDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MethodDecl(const MethodDecl& from);
  MethodDecl(MethodDecl&& from) noexcept
    : MethodDecl() {
    *this = ::std::move(from);
  }

  inline MethodDecl& operator=(const MethodDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline MethodDecl& operator=(MethodDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MethodDecl& default_instance() {
    return *internal_default_instance();
  }
  static inline const MethodDecl* internal_default_instance() {
    return reinterpret_cast<const MethodDecl*>(
               &_MethodDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MethodDecl& a, MethodDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(MethodDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MethodDecl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MethodDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MethodDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MethodDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MethodDecl& from) {
    MethodDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MethodDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.MethodDecl";
  }
  protected:
  explicit MethodDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 3,
    kLocalIndexFieldNumber = 5,
    kLineNumbersFieldNumber = 7,
    kExceptionEntryFieldNumber = 8,
    kBlockFieldNumber = 6,
    kFlagFieldNumber = 1,
    kNameTokenFieldNumber = 2,
    kRetTypeTokenFieldNumber = 4,
  };
  // repeated .Backage.ParameterDecl params = 3;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  ::Backage::ParameterDecl* mutable_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >*
      mutable_params();
  private:
  const ::Backage::ParameterDecl& _internal_params(int index) const;
  ::Backage::ParameterDecl* _internal_add_params();
  public:
  const ::Backage::ParameterDecl& params(int index) const;
  ::Backage::ParameterDecl* add_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >&
      params() const;

  // repeated .Backage.LocalIndex localIndex = 5;
  int localindex_size() const;
  private:
  int _internal_localindex_size() const;
  public:
  void clear_localindex();
  ::Backage::LocalIndex* mutable_localindex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex >*
      mutable_localindex();
  private:
  const ::Backage::LocalIndex& _internal_localindex(int index) const;
  ::Backage::LocalIndex* _internal_add_localindex();
  public:
  const ::Backage::LocalIndex& localindex(int index) const;
  ::Backage::LocalIndex* add_localindex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex >&
      localindex() const;

  // repeated .Backage.LineNumber lineNumbers = 7;
  int linenumbers_size() const;
  private:
  int _internal_linenumbers_size() const;
  public:
  void clear_linenumbers();
  ::Backage::LineNumber* mutable_linenumbers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber >*
      mutable_linenumbers();
  private:
  const ::Backage::LineNumber& _internal_linenumbers(int index) const;
  ::Backage::LineNumber* _internal_add_linenumbers();
  public:
  const ::Backage::LineNumber& linenumbers(int index) const;
  ::Backage::LineNumber* add_linenumbers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber >&
      linenumbers() const;

  // repeated .Backage.ExceptionEntry exceptionEntry = 8;
  int exceptionentry_size() const;
  private:
  int _internal_exceptionentry_size() const;
  public:
  void clear_exceptionentry();
  ::Backage::ExceptionEntry* mutable_exceptionentry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry >*
      mutable_exceptionentry();
  private:
  const ::Backage::ExceptionEntry& _internal_exceptionentry(int index) const;
  ::Backage::ExceptionEntry* _internal_add_exceptionentry();
  public:
  const ::Backage::ExceptionEntry& exceptionentry(int index) const;
  ::Backage::ExceptionEntry* add_exceptionentry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry >&
      exceptionentry() const;

  // bytes block = 6;
  void clear_block();
  const std::string& block() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block();
  PROTOBUF_NODISCARD std::string* release_block();
  void set_allocated_block(std::string* block);
  private:
  const std::string& _internal_block() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block(const std::string& value);
  std::string* _internal_mutable_block();
  public:

  // uint32 flag = 1;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // uint32 nameToken = 2;
  void clear_nametoken();
  uint32_t nametoken() const;
  void set_nametoken(uint32_t value);
  private:
  uint32_t _internal_nametoken() const;
  void _internal_set_nametoken(uint32_t value);
  public:

  // uint32 retTypeToken = 4;
  void clear_rettypetoken();
  uint32_t rettypetoken() const;
  void set_rettypetoken(uint32_t value);
  private:
  uint32_t _internal_rettypetoken() const;
  void _internal_set_rettypetoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.MethodDecl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl > params_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex > localindex_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber > linenumbers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry > exceptionentry_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_;
    uint32_t flag_;
    uint32_t nametoken_;
    uint32_t rettypetoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class CtorDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.CtorDecl) */ {
 public:
  inline CtorDecl() : CtorDecl(nullptr) {}
  ~CtorDecl() override;
  explicit PROTOBUF_CONSTEXPR CtorDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CtorDecl(const CtorDecl& from);
  CtorDecl(CtorDecl&& from) noexcept
    : CtorDecl() {
    *this = ::std::move(from);
  }

  inline CtorDecl& operator=(const CtorDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline CtorDecl& operator=(CtorDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CtorDecl& default_instance() {
    return *internal_default_instance();
  }
  static inline const CtorDecl* internal_default_instance() {
    return reinterpret_cast<const CtorDecl*>(
               &_CtorDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CtorDecl& a, CtorDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(CtorDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CtorDecl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CtorDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CtorDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CtorDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CtorDecl& from) {
    CtorDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CtorDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.CtorDecl";
  }
  protected:
  explicit CtorDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 2,
    kLocalIndexFieldNumber = 3,
    kLineNumbersFieldNumber = 5,
    kExceptionEntryFieldNumber = 6,
    kBlockFieldNumber = 4,
    kFlagFieldNumber = 1,
  };
  // repeated .Backage.ParameterDecl params = 2;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  ::Backage::ParameterDecl* mutable_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >*
      mutable_params();
  private:
  const ::Backage::ParameterDecl& _internal_params(int index) const;
  ::Backage::ParameterDecl* _internal_add_params();
  public:
  const ::Backage::ParameterDecl& params(int index) const;
  ::Backage::ParameterDecl* add_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >&
      params() const;

  // repeated .Backage.LocalIndex localIndex = 3;
  int localindex_size() const;
  private:
  int _internal_localindex_size() const;
  public:
  void clear_localindex();
  ::Backage::LocalIndex* mutable_localindex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex >*
      mutable_localindex();
  private:
  const ::Backage::LocalIndex& _internal_localindex(int index) const;
  ::Backage::LocalIndex* _internal_add_localindex();
  public:
  const ::Backage::LocalIndex& localindex(int index) const;
  ::Backage::LocalIndex* add_localindex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex >&
      localindex() const;

  // repeated .Backage.LineNumber lineNumbers = 5;
  int linenumbers_size() const;
  private:
  int _internal_linenumbers_size() const;
  public:
  void clear_linenumbers();
  ::Backage::LineNumber* mutable_linenumbers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber >*
      mutable_linenumbers();
  private:
  const ::Backage::LineNumber& _internal_linenumbers(int index) const;
  ::Backage::LineNumber* _internal_add_linenumbers();
  public:
  const ::Backage::LineNumber& linenumbers(int index) const;
  ::Backage::LineNumber* add_linenumbers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber >&
      linenumbers() const;

  // repeated .Backage.ExceptionEntry exceptionEntry = 6;
  int exceptionentry_size() const;
  private:
  int _internal_exceptionentry_size() const;
  public:
  void clear_exceptionentry();
  ::Backage::ExceptionEntry* mutable_exceptionentry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry >*
      mutable_exceptionentry();
  private:
  const ::Backage::ExceptionEntry& _internal_exceptionentry(int index) const;
  ::Backage::ExceptionEntry* _internal_add_exceptionentry();
  public:
  const ::Backage::ExceptionEntry& exceptionentry(int index) const;
  ::Backage::ExceptionEntry* add_exceptionentry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry >&
      exceptionentry() const;

  // bytes block = 4;
  void clear_block();
  const std::string& block() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block();
  PROTOBUF_NODISCARD std::string* release_block();
  void set_allocated_block(std::string* block);
  private:
  const std::string& _internal_block() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block(const std::string& value);
  std::string* _internal_mutable_block();
  public:

  // uint32 flag = 1;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.CtorDecl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl > params_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex > localindex_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber > linenumbers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry > exceptionentry_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_;
    uint32_t flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class ForeignEntryDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.ForeignEntryDecl) */ {
 public:
  inline ForeignEntryDecl() : ForeignEntryDecl(nullptr) {}
  ~ForeignEntryDecl() override;
  explicit PROTOBUF_CONSTEXPR ForeignEntryDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForeignEntryDecl(const ForeignEntryDecl& from);
  ForeignEntryDecl(ForeignEntryDecl&& from) noexcept
    : ForeignEntryDecl() {
    *this = ::std::move(from);
  }

  inline ForeignEntryDecl& operator=(const ForeignEntryDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForeignEntryDecl& operator=(ForeignEntryDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForeignEntryDecl& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForeignEntryDecl* internal_default_instance() {
    return reinterpret_cast<const ForeignEntryDecl*>(
               &_ForeignEntryDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ForeignEntryDecl& a, ForeignEntryDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(ForeignEntryDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForeignEntryDecl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForeignEntryDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForeignEntryDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForeignEntryDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForeignEntryDecl& from) {
    ForeignEntryDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForeignEntryDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.ForeignEntryDecl";
  }
  protected:
  explicit ForeignEntryDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 3,
    kBlockFieldNumber = 5,
    kLibFieldNumber = 6,
    kAliasFieldNumber = 7,
    kFlagFieldNumber = 1,
    kNameTokenFieldNumber = 2,
    kRetTypeTokenFieldNumber = 4,
  };
  // repeated .Backage.ParameterDecl params = 3;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  ::Backage::ParameterDecl* mutable_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >*
      mutable_params();
  private:
  const ::Backage::ParameterDecl& _internal_params(int index) const;
  ::Backage::ParameterDecl* _internal_add_params();
  public:
  const ::Backage::ParameterDecl& params(int index) const;
  ::Backage::ParameterDecl* add_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >&
      params() const;

  // bytes block = 5;
  void clear_block();
  const std::string& block() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block();
  PROTOBUF_NODISCARD std::string* release_block();
  void set_allocated_block(std::string* block);
  private:
  const std::string& _internal_block() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block(const std::string& value);
  std::string* _internal_mutable_block();
  public:

  // optional bytes lib = 6;
  bool has_lib() const;
  private:
  bool _internal_has_lib() const;
  public:
  void clear_lib();
  const std::string& lib() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lib(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lib();
  PROTOBUF_NODISCARD std::string* release_lib();
  void set_allocated_lib(std::string* lib);
  private:
  const std::string& _internal_lib() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lib(const std::string& value);
  std::string* _internal_mutable_lib();
  public:

  // optional bytes alias = 7;
  bool has_alias() const;
  private:
  bool _internal_has_alias() const;
  public:
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // uint32 flag = 1;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // uint32 nameToken = 2;
  void clear_nametoken();
  uint32_t nametoken() const;
  void set_nametoken(uint32_t value);
  private:
  uint32_t _internal_nametoken() const;
  void _internal_set_nametoken(uint32_t value);
  public:

  // uint32 retTypeToken = 4;
  void clear_rettypetoken();
  uint32_t rettypetoken() const;
  void set_rettypetoken(uint32_t value);
  private:
  uint32_t _internal_rettypetoken() const;
  void _internal_set_rettypetoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.ForeignEntryDecl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl > params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lib_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
    uint32_t flag_;
    uint32_t nametoken_;
    uint32_t rettypetoken_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class LineNumber final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.LineNumber) */ {
 public:
  inline LineNumber() : LineNumber(nullptr) {}
  ~LineNumber() override;
  explicit PROTOBUF_CONSTEXPR LineNumber(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineNumber(const LineNumber& from);
  LineNumber(LineNumber&& from) noexcept
    : LineNumber() {
    *this = ::std::move(from);
  }

  inline LineNumber& operator=(const LineNumber& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineNumber& operator=(LineNumber&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineNumber& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineNumber* internal_default_instance() {
    return reinterpret_cast<const LineNumber*>(
               &_LineNumber_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LineNumber& a, LineNumber& b) {
    a.Swap(&b);
  }
  inline void Swap(LineNumber* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineNumber* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineNumber* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineNumber>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineNumber& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineNumber& from) {
    LineNumber::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineNumber* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.LineNumber";
  }
  protected:
  explicit LineNumber(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // uint32 line = 1;
  void clear_line();
  uint32_t line() const;
  void set_line(uint32_t value);
  private:
  uint32_t _internal_line() const;
  void _internal_set_line(uint32_t value);
  public:

  // uint32 offset = 2;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.LineNumber)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t line_;
    uint32_t offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// -------------------------------------------------------------------

class ExceptionEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backage.ExceptionEntry) */ {
 public:
  inline ExceptionEntry() : ExceptionEntry(nullptr) {}
  ~ExceptionEntry() override;
  explicit PROTOBUF_CONSTEXPR ExceptionEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExceptionEntry(const ExceptionEntry& from);
  ExceptionEntry(ExceptionEntry&& from) noexcept
    : ExceptionEntry() {
    *this = ::std::move(from);
  }

  inline ExceptionEntry& operator=(const ExceptionEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExceptionEntry& operator=(ExceptionEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExceptionEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExceptionEntry* internal_default_instance() {
    return reinterpret_cast<const ExceptionEntry*>(
               &_ExceptionEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ExceptionEntry& a, ExceptionEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ExceptionEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExceptionEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExceptionEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExceptionEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExceptionEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExceptionEntry& from) {
    ExceptionEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExceptionEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backage.ExceptionEntry";
  }
  protected:
  explicit ExceptionEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kLengthFieldNumber = 2,
    kTargetFieldNumber = 3,
    kTypeTokenFieldNumber = 4,
  };
  // uint32 offset = 1;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // uint32 length = 2;
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // uint32 target = 3;
  void clear_target();
  uint32_t target() const;
  void set_target(uint32_t value);
  private:
  uint32_t _internal_target() const;
  void _internal_set_target(uint32_t value);
  public:

  // uint32 typeToken = 4;
  void clear_typetoken();
  uint32_t typetoken() const;
  void set_typetoken(uint32_t value);
  private:
  uint32_t _internal_typetoken() const;
  void _internal_set_typetoken(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Backage.ExceptionEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t offset_;
    uint32_t length_;
    uint32_t target_;
    uint32_t typetoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Dependency

// string text = 1;
inline void Dependency::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& Dependency::text() const {
  // @@protoc_insertion_point(field_get:Backage.Dependency.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dependency::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.Dependency.text)
}
inline std::string* Dependency::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Backage.Dependency.text)
  return _s;
}
inline const std::string& Dependency::_internal_text() const {
  return _impl_.text_.Get();
}
inline void Dependency::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Dependency::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* Dependency::release_text() {
  // @@protoc_insertion_point(field_release:Backage.Dependency.text)
  return _impl_.text_.Release();
}
inline void Dependency::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.Dependency.text)
}

// -------------------------------------------------------------------

// TextToken

// string text = 1;
inline void TextToken::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TextToken::text() const {
  // @@protoc_insertion_point(field_get:Backage.TextToken.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextToken::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.TextToken.text)
}
inline std::string* TextToken::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Backage.TextToken.text)
  return _s;
}
inline const std::string& TextToken::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TextToken::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextToken::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TextToken::release_text() {
  // @@protoc_insertion_point(field_release:Backage.TextToken.text)
  return _impl_.text_.Release();
}
inline void TextToken::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.TextToken.text)
}

// -------------------------------------------------------------------

// ConstructedToken

// repeated uint32 tokens = 1;
inline int ConstructedToken::_internal_tokens_size() const {
  return _impl_.tokens_.size();
}
inline int ConstructedToken::tokens_size() const {
  return _internal_tokens_size();
}
inline void ConstructedToken::clear_tokens() {
  _impl_.tokens_.Clear();
}
inline uint32_t ConstructedToken::_internal_tokens(int index) const {
  return _impl_.tokens_.Get(index);
}
inline uint32_t ConstructedToken::tokens(int index) const {
  // @@protoc_insertion_point(field_get:Backage.ConstructedToken.tokens)
  return _internal_tokens(index);
}
inline void ConstructedToken::set_tokens(int index, uint32_t value) {
  _impl_.tokens_.Set(index, value);
  // @@protoc_insertion_point(field_set:Backage.ConstructedToken.tokens)
}
inline void ConstructedToken::_internal_add_tokens(uint32_t value) {
  _impl_.tokens_.Add(value);
}
inline void ConstructedToken::add_tokens(uint32_t value) {
  _internal_add_tokens(value);
  // @@protoc_insertion_point(field_add:Backage.ConstructedToken.tokens)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ConstructedToken::_internal_tokens() const {
  return _impl_.tokens_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ConstructedToken::tokens() const {
  // @@protoc_insertion_point(field_list:Backage.ConstructedToken.tokens)
  return _internal_tokens();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ConstructedToken::_internal_mutable_tokens() {
  return &_impl_.tokens_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ConstructedToken::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:Backage.ConstructedToken.tokens)
  return _internal_mutable_tokens();
}

// -------------------------------------------------------------------

// ArrayToken

// uint32 typeToken = 1;
inline void ArrayToken::clear_typetoken() {
  _impl_.typetoken_ = 0u;
}
inline uint32_t ArrayToken::_internal_typetoken() const {
  return _impl_.typetoken_;
}
inline uint32_t ArrayToken::typetoken() const {
  // @@protoc_insertion_point(field_get:Backage.ArrayToken.typeToken)
  return _internal_typetoken();
}
inline void ArrayToken::_internal_set_typetoken(uint32_t value) {
  
  _impl_.typetoken_ = value;
}
inline void ArrayToken::set_typetoken(uint32_t value) {
  _internal_set_typetoken(value);
  // @@protoc_insertion_point(field_set:Backage.ArrayToken.typeToken)
}

// -------------------------------------------------------------------

// TokenDefinition

// uint32 id = 1;
inline void TokenDefinition::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t TokenDefinition::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t TokenDefinition::id() const {
  // @@protoc_insertion_point(field_get:Backage.TokenDefinition.id)
  return _internal_id();
}
inline void TokenDefinition::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void TokenDefinition::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Backage.TokenDefinition.id)
}

// .Backage.TextToken textToken = 2;
inline bool TokenDefinition::_internal_has_texttoken() const {
  return definition_case() == kTextToken;
}
inline bool TokenDefinition::has_texttoken() const {
  return _internal_has_texttoken();
}
inline void TokenDefinition::set_has_texttoken() {
  _impl_._oneof_case_[0] = kTextToken;
}
inline void TokenDefinition::clear_texttoken() {
  if (_internal_has_texttoken()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.definition_.texttoken_;
    }
    clear_has_definition();
  }
}
inline ::Backage::TextToken* TokenDefinition::release_texttoken() {
  // @@protoc_insertion_point(field_release:Backage.TokenDefinition.textToken)
  if (_internal_has_texttoken()) {
    clear_has_definition();
    ::Backage::TextToken* temp = _impl_.definition_.texttoken_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.texttoken_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::TextToken& TokenDefinition::_internal_texttoken() const {
  return _internal_has_texttoken()
      ? *_impl_.definition_.texttoken_
      : reinterpret_cast< ::Backage::TextToken&>(::Backage::_TextToken_default_instance_);
}
inline const ::Backage::TextToken& TokenDefinition::texttoken() const {
  // @@protoc_insertion_point(field_get:Backage.TokenDefinition.textToken)
  return _internal_texttoken();
}
inline ::Backage::TextToken* TokenDefinition::unsafe_arena_release_texttoken() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.TokenDefinition.textToken)
  if (_internal_has_texttoken()) {
    clear_has_definition();
    ::Backage::TextToken* temp = _impl_.definition_.texttoken_;
    _impl_.definition_.texttoken_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TokenDefinition::unsafe_arena_set_allocated_texttoken(::Backage::TextToken* texttoken) {
  clear_definition();
  if (texttoken) {
    set_has_texttoken();
    _impl_.definition_.texttoken_ = texttoken;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.TokenDefinition.textToken)
}
inline ::Backage::TextToken* TokenDefinition::_internal_mutable_texttoken() {
  if (!_internal_has_texttoken()) {
    clear_definition();
    set_has_texttoken();
    _impl_.definition_.texttoken_ = CreateMaybeMessage< ::Backage::TextToken >(GetArenaForAllocation());
  }
  return _impl_.definition_.texttoken_;
}
inline ::Backage::TextToken* TokenDefinition::mutable_texttoken() {
  ::Backage::TextToken* _msg = _internal_mutable_texttoken();
  // @@protoc_insertion_point(field_mutable:Backage.TokenDefinition.textToken)
  return _msg;
}

// .Backage.ConstructedToken constructedToken = 3;
inline bool TokenDefinition::_internal_has_constructedtoken() const {
  return definition_case() == kConstructedToken;
}
inline bool TokenDefinition::has_constructedtoken() const {
  return _internal_has_constructedtoken();
}
inline void TokenDefinition::set_has_constructedtoken() {
  _impl_._oneof_case_[0] = kConstructedToken;
}
inline void TokenDefinition::clear_constructedtoken() {
  if (_internal_has_constructedtoken()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.definition_.constructedtoken_;
    }
    clear_has_definition();
  }
}
inline ::Backage::ConstructedToken* TokenDefinition::release_constructedtoken() {
  // @@protoc_insertion_point(field_release:Backage.TokenDefinition.constructedToken)
  if (_internal_has_constructedtoken()) {
    clear_has_definition();
    ::Backage::ConstructedToken* temp = _impl_.definition_.constructedtoken_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.constructedtoken_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::ConstructedToken& TokenDefinition::_internal_constructedtoken() const {
  return _internal_has_constructedtoken()
      ? *_impl_.definition_.constructedtoken_
      : reinterpret_cast< ::Backage::ConstructedToken&>(::Backage::_ConstructedToken_default_instance_);
}
inline const ::Backage::ConstructedToken& TokenDefinition::constructedtoken() const {
  // @@protoc_insertion_point(field_get:Backage.TokenDefinition.constructedToken)
  return _internal_constructedtoken();
}
inline ::Backage::ConstructedToken* TokenDefinition::unsafe_arena_release_constructedtoken() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.TokenDefinition.constructedToken)
  if (_internal_has_constructedtoken()) {
    clear_has_definition();
    ::Backage::ConstructedToken* temp = _impl_.definition_.constructedtoken_;
    _impl_.definition_.constructedtoken_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TokenDefinition::unsafe_arena_set_allocated_constructedtoken(::Backage::ConstructedToken* constructedtoken) {
  clear_definition();
  if (constructedtoken) {
    set_has_constructedtoken();
    _impl_.definition_.constructedtoken_ = constructedtoken;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.TokenDefinition.constructedToken)
}
inline ::Backage::ConstructedToken* TokenDefinition::_internal_mutable_constructedtoken() {
  if (!_internal_has_constructedtoken()) {
    clear_definition();
    set_has_constructedtoken();
    _impl_.definition_.constructedtoken_ = CreateMaybeMessage< ::Backage::ConstructedToken >(GetArenaForAllocation());
  }
  return _impl_.definition_.constructedtoken_;
}
inline ::Backage::ConstructedToken* TokenDefinition::mutable_constructedtoken() {
  ::Backage::ConstructedToken* _msg = _internal_mutable_constructedtoken();
  // @@protoc_insertion_point(field_mutable:Backage.TokenDefinition.constructedToken)
  return _msg;
}

// .Backage.ArrayToken arrayToken = 4;
inline bool TokenDefinition::_internal_has_arraytoken() const {
  return definition_case() == kArrayToken;
}
inline bool TokenDefinition::has_arraytoken() const {
  return _internal_has_arraytoken();
}
inline void TokenDefinition::set_has_arraytoken() {
  _impl_._oneof_case_[0] = kArrayToken;
}
inline void TokenDefinition::clear_arraytoken() {
  if (_internal_has_arraytoken()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.definition_.arraytoken_;
    }
    clear_has_definition();
  }
}
inline ::Backage::ArrayToken* TokenDefinition::release_arraytoken() {
  // @@protoc_insertion_point(field_release:Backage.TokenDefinition.arrayToken)
  if (_internal_has_arraytoken()) {
    clear_has_definition();
    ::Backage::ArrayToken* temp = _impl_.definition_.arraytoken_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.arraytoken_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::ArrayToken& TokenDefinition::_internal_arraytoken() const {
  return _internal_has_arraytoken()
      ? *_impl_.definition_.arraytoken_
      : reinterpret_cast< ::Backage::ArrayToken&>(::Backage::_ArrayToken_default_instance_);
}
inline const ::Backage::ArrayToken& TokenDefinition::arraytoken() const {
  // @@protoc_insertion_point(field_get:Backage.TokenDefinition.arrayToken)
  return _internal_arraytoken();
}
inline ::Backage::ArrayToken* TokenDefinition::unsafe_arena_release_arraytoken() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.TokenDefinition.arrayToken)
  if (_internal_has_arraytoken()) {
    clear_has_definition();
    ::Backage::ArrayToken* temp = _impl_.definition_.arraytoken_;
    _impl_.definition_.arraytoken_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TokenDefinition::unsafe_arena_set_allocated_arraytoken(::Backage::ArrayToken* arraytoken) {
  clear_definition();
  if (arraytoken) {
    set_has_arraytoken();
    _impl_.definition_.arraytoken_ = arraytoken;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.TokenDefinition.arrayToken)
}
inline ::Backage::ArrayToken* TokenDefinition::_internal_mutable_arraytoken() {
  if (!_internal_has_arraytoken()) {
    clear_definition();
    set_has_arraytoken();
    _impl_.definition_.arraytoken_ = CreateMaybeMessage< ::Backage::ArrayToken >(GetArenaForAllocation());
  }
  return _impl_.definition_.arraytoken_;
}
inline ::Backage::ArrayToken* TokenDefinition::mutable_arraytoken() {
  ::Backage::ArrayToken* _msg = _internal_mutable_arraytoken();
  // @@protoc_insertion_point(field_mutable:Backage.TokenDefinition.arrayToken)
  return _msg;
}

inline bool TokenDefinition::has_definition() const {
  return definition_case() != DEFINITION_NOT_SET;
}
inline void TokenDefinition::clear_has_definition() {
  _impl_._oneof_case_[0] = DEFINITION_NOT_SET;
}
inline TokenDefinition::DefinitionCase TokenDefinition::definition_case() const {
  return TokenDefinition::DefinitionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Package

// repeated .Backage.Dependency dependencies = 1;
inline int Package::_internal_dependencies_size() const {
  return _impl_.dependencies_.size();
}
inline int Package::dependencies_size() const {
  return _internal_dependencies_size();
}
inline void Package::clear_dependencies() {
  _impl_.dependencies_.Clear();
}
inline ::Backage::Dependency* Package::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.Package.dependencies)
  return _impl_.dependencies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Dependency >*
Package::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:Backage.Package.dependencies)
  return &_impl_.dependencies_;
}
inline const ::Backage::Dependency& Package::_internal_dependencies(int index) const {
  return _impl_.dependencies_.Get(index);
}
inline const ::Backage::Dependency& Package::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:Backage.Package.dependencies)
  return _internal_dependencies(index);
}
inline ::Backage::Dependency* Package::_internal_add_dependencies() {
  return _impl_.dependencies_.Add();
}
inline ::Backage::Dependency* Package::add_dependencies() {
  ::Backage::Dependency* _add = _internal_add_dependencies();
  // @@protoc_insertion_point(field_add:Backage.Package.dependencies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Dependency >&
Package::dependencies() const {
  // @@protoc_insertion_point(field_list:Backage.Package.dependencies)
  return _impl_.dependencies_;
}

// repeated .Backage.TokenDefinition tokens = 2;
inline int Package::_internal_tokens_size() const {
  return _impl_.tokens_.size();
}
inline int Package::tokens_size() const {
  return _internal_tokens_size();
}
inline void Package::clear_tokens() {
  _impl_.tokens_.Clear();
}
inline ::Backage::TokenDefinition* Package::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.Package.tokens)
  return _impl_.tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::TokenDefinition >*
Package::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:Backage.Package.tokens)
  return &_impl_.tokens_;
}
inline const ::Backage::TokenDefinition& Package::_internal_tokens(int index) const {
  return _impl_.tokens_.Get(index);
}
inline const ::Backage::TokenDefinition& Package::tokens(int index) const {
  // @@protoc_insertion_point(field_get:Backage.Package.tokens)
  return _internal_tokens(index);
}
inline ::Backage::TokenDefinition* Package::_internal_add_tokens() {
  return _impl_.tokens_.Add();
}
inline ::Backage::TokenDefinition* Package::add_tokens() {
  ::Backage::TokenDefinition* _add = _internal_add_tokens();
  // @@protoc_insertion_point(field_add:Backage.Package.tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::TokenDefinition >&
Package::tokens() const {
  // @@protoc_insertion_point(field_list:Backage.Package.tokens)
  return _impl_.tokens_;
}

// repeated .Backage.Declaration declarations = 3;
inline int Package::_internal_declarations_size() const {
  return _impl_.declarations_.size();
}
inline int Package::declarations_size() const {
  return _internal_declarations_size();
}
inline void Package::clear_declarations() {
  _impl_.declarations_.Clear();
}
inline ::Backage::Declaration* Package::mutable_declarations(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.Package.declarations)
  return _impl_.declarations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >*
Package::mutable_declarations() {
  // @@protoc_insertion_point(field_mutable_list:Backage.Package.declarations)
  return &_impl_.declarations_;
}
inline const ::Backage::Declaration& Package::_internal_declarations(int index) const {
  return _impl_.declarations_.Get(index);
}
inline const ::Backage::Declaration& Package::declarations(int index) const {
  // @@protoc_insertion_point(field_get:Backage.Package.declarations)
  return _internal_declarations(index);
}
inline ::Backage::Declaration* Package::_internal_add_declarations() {
  return _impl_.declarations_.Add();
}
inline ::Backage::Declaration* Package::add_declarations() {
  ::Backage::Declaration* _add = _internal_add_declarations();
  // @@protoc_insertion_point(field_add:Backage.Package.declarations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >&
Package::declarations() const {
  // @@protoc_insertion_point(field_list:Backage.Package.declarations)
  return _impl_.declarations_;
}

// string identity = 4;
inline void Package::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& Package::identity() const {
  // @@protoc_insertion_point(field_get:Backage.Package.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Package::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.Package.identity)
}
inline std::string* Package::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:Backage.Package.identity)
  return _s;
}
inline const std::string& Package::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void Package::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* Package::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* Package::release_identity() {
  // @@protoc_insertion_point(field_release:Backage.Package.identity)
  return _impl_.identity_.Release();
}
inline void Package::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.Package.identity)
}

// uint64 version = 5;
inline void Package::clear_version() {
  _impl_.version_ = uint64_t{0u};
}
inline uint64_t Package::_internal_version() const {
  return _impl_.version_;
}
inline uint64_t Package::version() const {
  // @@protoc_insertion_point(field_get:Backage.Package.version)
  return _internal_version();
}
inline void Package::_internal_set_version(uint64_t value) {
  
  _impl_.version_ = value;
}
inline void Package::set_version(uint64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:Backage.Package.version)
}

// -------------------------------------------------------------------

// Declaration

// .Backage.ClassDecl classDecl = 1;
inline bool Declaration::_internal_has_classdecl() const {
  return Member_case() == kClassDecl;
}
inline bool Declaration::has_classdecl() const {
  return _internal_has_classdecl();
}
inline void Declaration::set_has_classdecl() {
  _impl_._oneof_case_[0] = kClassDecl;
}
inline void Declaration::clear_classdecl() {
  if (_internal_has_classdecl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Member_.classdecl_;
    }
    clear_has_Member();
  }
}
inline ::Backage::ClassDecl* Declaration::release_classdecl() {
  // @@protoc_insertion_point(field_release:Backage.Declaration.classDecl)
  if (_internal_has_classdecl()) {
    clear_has_Member();
    ::Backage::ClassDecl* temp = _impl_.Member_.classdecl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Member_.classdecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::ClassDecl& Declaration::_internal_classdecl() const {
  return _internal_has_classdecl()
      ? *_impl_.Member_.classdecl_
      : reinterpret_cast< ::Backage::ClassDecl&>(::Backage::_ClassDecl_default_instance_);
}
inline const ::Backage::ClassDecl& Declaration::classdecl() const {
  // @@protoc_insertion_point(field_get:Backage.Declaration.classDecl)
  return _internal_classdecl();
}
inline ::Backage::ClassDecl* Declaration::unsafe_arena_release_classdecl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.Declaration.classDecl)
  if (_internal_has_classdecl()) {
    clear_has_Member();
    ::Backage::ClassDecl* temp = _impl_.Member_.classdecl_;
    _impl_.Member_.classdecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Declaration::unsafe_arena_set_allocated_classdecl(::Backage::ClassDecl* classdecl) {
  clear_Member();
  if (classdecl) {
    set_has_classdecl();
    _impl_.Member_.classdecl_ = classdecl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.Declaration.classDecl)
}
inline ::Backage::ClassDecl* Declaration::_internal_mutable_classdecl() {
  if (!_internal_has_classdecl()) {
    clear_Member();
    set_has_classdecl();
    _impl_.Member_.classdecl_ = CreateMaybeMessage< ::Backage::ClassDecl >(GetArenaForAllocation());
  }
  return _impl_.Member_.classdecl_;
}
inline ::Backage::ClassDecl* Declaration::mutable_classdecl() {
  ::Backage::ClassDecl* _msg = _internal_mutable_classdecl();
  // @@protoc_insertion_point(field_mutable:Backage.Declaration.classDecl)
  return _msg;
}

// .Backage.RecordDecl recordDecl = 2;
inline bool Declaration::_internal_has_recorddecl() const {
  return Member_case() == kRecordDecl;
}
inline bool Declaration::has_recorddecl() const {
  return _internal_has_recorddecl();
}
inline void Declaration::set_has_recorddecl() {
  _impl_._oneof_case_[0] = kRecordDecl;
}
inline void Declaration::clear_recorddecl() {
  if (_internal_has_recorddecl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Member_.recorddecl_;
    }
    clear_has_Member();
  }
}
inline ::Backage::RecordDecl* Declaration::release_recorddecl() {
  // @@protoc_insertion_point(field_release:Backage.Declaration.recordDecl)
  if (_internal_has_recorddecl()) {
    clear_has_Member();
    ::Backage::RecordDecl* temp = _impl_.Member_.recorddecl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Member_.recorddecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::RecordDecl& Declaration::_internal_recorddecl() const {
  return _internal_has_recorddecl()
      ? *_impl_.Member_.recorddecl_
      : reinterpret_cast< ::Backage::RecordDecl&>(::Backage::_RecordDecl_default_instance_);
}
inline const ::Backage::RecordDecl& Declaration::recorddecl() const {
  // @@protoc_insertion_point(field_get:Backage.Declaration.recordDecl)
  return _internal_recorddecl();
}
inline ::Backage::RecordDecl* Declaration::unsafe_arena_release_recorddecl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.Declaration.recordDecl)
  if (_internal_has_recorddecl()) {
    clear_has_Member();
    ::Backage::RecordDecl* temp = _impl_.Member_.recorddecl_;
    _impl_.Member_.recorddecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Declaration::unsafe_arena_set_allocated_recorddecl(::Backage::RecordDecl* recorddecl) {
  clear_Member();
  if (recorddecl) {
    set_has_recorddecl();
    _impl_.Member_.recorddecl_ = recorddecl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.Declaration.recordDecl)
}
inline ::Backage::RecordDecl* Declaration::_internal_mutable_recorddecl() {
  if (!_internal_has_recorddecl()) {
    clear_Member();
    set_has_recorddecl();
    _impl_.Member_.recorddecl_ = CreateMaybeMessage< ::Backage::RecordDecl >(GetArenaForAllocation());
  }
  return _impl_.Member_.recorddecl_;
}
inline ::Backage::RecordDecl* Declaration::mutable_recorddecl() {
  ::Backage::RecordDecl* _msg = _internal_mutable_recorddecl();
  // @@protoc_insertion_point(field_mutable:Backage.Declaration.recordDecl)
  return _msg;
}

// .Backage.EnumDecl enumDecl = 3;
inline bool Declaration::_internal_has_enumdecl() const {
  return Member_case() == kEnumDecl;
}
inline bool Declaration::has_enumdecl() const {
  return _internal_has_enumdecl();
}
inline void Declaration::set_has_enumdecl() {
  _impl_._oneof_case_[0] = kEnumDecl;
}
inline void Declaration::clear_enumdecl() {
  if (_internal_has_enumdecl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Member_.enumdecl_;
    }
    clear_has_Member();
  }
}
inline ::Backage::EnumDecl* Declaration::release_enumdecl() {
  // @@protoc_insertion_point(field_release:Backage.Declaration.enumDecl)
  if (_internal_has_enumdecl()) {
    clear_has_Member();
    ::Backage::EnumDecl* temp = _impl_.Member_.enumdecl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Member_.enumdecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::EnumDecl& Declaration::_internal_enumdecl() const {
  return _internal_has_enumdecl()
      ? *_impl_.Member_.enumdecl_
      : reinterpret_cast< ::Backage::EnumDecl&>(::Backage::_EnumDecl_default_instance_);
}
inline const ::Backage::EnumDecl& Declaration::enumdecl() const {
  // @@protoc_insertion_point(field_get:Backage.Declaration.enumDecl)
  return _internal_enumdecl();
}
inline ::Backage::EnumDecl* Declaration::unsafe_arena_release_enumdecl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.Declaration.enumDecl)
  if (_internal_has_enumdecl()) {
    clear_has_Member();
    ::Backage::EnumDecl* temp = _impl_.Member_.enumdecl_;
    _impl_.Member_.enumdecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Declaration::unsafe_arena_set_allocated_enumdecl(::Backage::EnumDecl* enumdecl) {
  clear_Member();
  if (enumdecl) {
    set_has_enumdecl();
    _impl_.Member_.enumdecl_ = enumdecl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.Declaration.enumDecl)
}
inline ::Backage::EnumDecl* Declaration::_internal_mutable_enumdecl() {
  if (!_internal_has_enumdecl()) {
    clear_Member();
    set_has_enumdecl();
    _impl_.Member_.enumdecl_ = CreateMaybeMessage< ::Backage::EnumDecl >(GetArenaForAllocation());
  }
  return _impl_.Member_.enumdecl_;
}
inline ::Backage::EnumDecl* Declaration::mutable_enumdecl() {
  ::Backage::EnumDecl* _msg = _internal_mutable_enumdecl();
  // @@protoc_insertion_point(field_mutable:Backage.Declaration.enumDecl)
  return _msg;
}

// .Backage.EnumConstant enumConstant = 4;
inline bool Declaration::_internal_has_enumconstant() const {
  return Member_case() == kEnumConstant;
}
inline bool Declaration::has_enumconstant() const {
  return _internal_has_enumconstant();
}
inline void Declaration::set_has_enumconstant() {
  _impl_._oneof_case_[0] = kEnumConstant;
}
inline void Declaration::clear_enumconstant() {
  if (_internal_has_enumconstant()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Member_.enumconstant_;
    }
    clear_has_Member();
  }
}
inline ::Backage::EnumConstant* Declaration::release_enumconstant() {
  // @@protoc_insertion_point(field_release:Backage.Declaration.enumConstant)
  if (_internal_has_enumconstant()) {
    clear_has_Member();
    ::Backage::EnumConstant* temp = _impl_.Member_.enumconstant_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Member_.enumconstant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::EnumConstant& Declaration::_internal_enumconstant() const {
  return _internal_has_enumconstant()
      ? *_impl_.Member_.enumconstant_
      : reinterpret_cast< ::Backage::EnumConstant&>(::Backage::_EnumConstant_default_instance_);
}
inline const ::Backage::EnumConstant& Declaration::enumconstant() const {
  // @@protoc_insertion_point(field_get:Backage.Declaration.enumConstant)
  return _internal_enumconstant();
}
inline ::Backage::EnumConstant* Declaration::unsafe_arena_release_enumconstant() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.Declaration.enumConstant)
  if (_internal_has_enumconstant()) {
    clear_has_Member();
    ::Backage::EnumConstant* temp = _impl_.Member_.enumconstant_;
    _impl_.Member_.enumconstant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Declaration::unsafe_arena_set_allocated_enumconstant(::Backage::EnumConstant* enumconstant) {
  clear_Member();
  if (enumconstant) {
    set_has_enumconstant();
    _impl_.Member_.enumconstant_ = enumconstant;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.Declaration.enumConstant)
}
inline ::Backage::EnumConstant* Declaration::_internal_mutable_enumconstant() {
  if (!_internal_has_enumconstant()) {
    clear_Member();
    set_has_enumconstant();
    _impl_.Member_.enumconstant_ = CreateMaybeMessage< ::Backage::EnumConstant >(GetArenaForAllocation());
  }
  return _impl_.Member_.enumconstant_;
}
inline ::Backage::EnumConstant* Declaration::mutable_enumconstant() {
  ::Backage::EnumConstant* _msg = _internal_mutable_enumconstant();
  // @@protoc_insertion_point(field_mutable:Backage.Declaration.enumConstant)
  return _msg;
}

// .Backage.VariableDecl varaibleDecl = 5;
inline bool Declaration::_internal_has_varaibledecl() const {
  return Member_case() == kVaraibleDecl;
}
inline bool Declaration::has_varaibledecl() const {
  return _internal_has_varaibledecl();
}
inline void Declaration::set_has_varaibledecl() {
  _impl_._oneof_case_[0] = kVaraibleDecl;
}
inline void Declaration::clear_varaibledecl() {
  if (_internal_has_varaibledecl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Member_.varaibledecl_;
    }
    clear_has_Member();
  }
}
inline ::Backage::VariableDecl* Declaration::release_varaibledecl() {
  // @@protoc_insertion_point(field_release:Backage.Declaration.varaibleDecl)
  if (_internal_has_varaibledecl()) {
    clear_has_Member();
    ::Backage::VariableDecl* temp = _impl_.Member_.varaibledecl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Member_.varaibledecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::VariableDecl& Declaration::_internal_varaibledecl() const {
  return _internal_has_varaibledecl()
      ? *_impl_.Member_.varaibledecl_
      : reinterpret_cast< ::Backage::VariableDecl&>(::Backage::_VariableDecl_default_instance_);
}
inline const ::Backage::VariableDecl& Declaration::varaibledecl() const {
  // @@protoc_insertion_point(field_get:Backage.Declaration.varaibleDecl)
  return _internal_varaibledecl();
}
inline ::Backage::VariableDecl* Declaration::unsafe_arena_release_varaibledecl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.Declaration.varaibleDecl)
  if (_internal_has_varaibledecl()) {
    clear_has_Member();
    ::Backage::VariableDecl* temp = _impl_.Member_.varaibledecl_;
    _impl_.Member_.varaibledecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Declaration::unsafe_arena_set_allocated_varaibledecl(::Backage::VariableDecl* varaibledecl) {
  clear_Member();
  if (varaibledecl) {
    set_has_varaibledecl();
    _impl_.Member_.varaibledecl_ = varaibledecl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.Declaration.varaibleDecl)
}
inline ::Backage::VariableDecl* Declaration::_internal_mutable_varaibledecl() {
  if (!_internal_has_varaibledecl()) {
    clear_Member();
    set_has_varaibledecl();
    _impl_.Member_.varaibledecl_ = CreateMaybeMessage< ::Backage::VariableDecl >(GetArenaForAllocation());
  }
  return _impl_.Member_.varaibledecl_;
}
inline ::Backage::VariableDecl* Declaration::mutable_varaibledecl() {
  ::Backage::VariableDecl* _msg = _internal_mutable_varaibledecl();
  // @@protoc_insertion_point(field_mutable:Backage.Declaration.varaibleDecl)
  return _msg;
}

// .Backage.ModuleDecl moduleDecl = 6;
inline bool Declaration::_internal_has_moduledecl() const {
  return Member_case() == kModuleDecl;
}
inline bool Declaration::has_moduledecl() const {
  return _internal_has_moduledecl();
}
inline void Declaration::set_has_moduledecl() {
  _impl_._oneof_case_[0] = kModuleDecl;
}
inline void Declaration::clear_moduledecl() {
  if (_internal_has_moduledecl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Member_.moduledecl_;
    }
    clear_has_Member();
  }
}
inline ::Backage::ModuleDecl* Declaration::release_moduledecl() {
  // @@protoc_insertion_point(field_release:Backage.Declaration.moduleDecl)
  if (_internal_has_moduledecl()) {
    clear_has_Member();
    ::Backage::ModuleDecl* temp = _impl_.Member_.moduledecl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Member_.moduledecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::ModuleDecl& Declaration::_internal_moduledecl() const {
  return _internal_has_moduledecl()
      ? *_impl_.Member_.moduledecl_
      : reinterpret_cast< ::Backage::ModuleDecl&>(::Backage::_ModuleDecl_default_instance_);
}
inline const ::Backage::ModuleDecl& Declaration::moduledecl() const {
  // @@protoc_insertion_point(field_get:Backage.Declaration.moduleDecl)
  return _internal_moduledecl();
}
inline ::Backage::ModuleDecl* Declaration::unsafe_arena_release_moduledecl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.Declaration.moduleDecl)
  if (_internal_has_moduledecl()) {
    clear_has_Member();
    ::Backage::ModuleDecl* temp = _impl_.Member_.moduledecl_;
    _impl_.Member_.moduledecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Declaration::unsafe_arena_set_allocated_moduledecl(::Backage::ModuleDecl* moduledecl) {
  clear_Member();
  if (moduledecl) {
    set_has_moduledecl();
    _impl_.Member_.moduledecl_ = moduledecl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.Declaration.moduleDecl)
}
inline ::Backage::ModuleDecl* Declaration::_internal_mutable_moduledecl() {
  if (!_internal_has_moduledecl()) {
    clear_Member();
    set_has_moduledecl();
    _impl_.Member_.moduledecl_ = CreateMaybeMessage< ::Backage::ModuleDecl >(GetArenaForAllocation());
  }
  return _impl_.Member_.moduledecl_;
}
inline ::Backage::ModuleDecl* Declaration::mutable_moduledecl() {
  ::Backage::ModuleDecl* _msg = _internal_mutable_moduledecl();
  // @@protoc_insertion_point(field_mutable:Backage.Declaration.moduleDecl)
  return _msg;
}

// .Backage.MethodDecl methodDecl = 7;
inline bool Declaration::_internal_has_methoddecl() const {
  return Member_case() == kMethodDecl;
}
inline bool Declaration::has_methoddecl() const {
  return _internal_has_methoddecl();
}
inline void Declaration::set_has_methoddecl() {
  _impl_._oneof_case_[0] = kMethodDecl;
}
inline void Declaration::clear_methoddecl() {
  if (_internal_has_methoddecl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Member_.methoddecl_;
    }
    clear_has_Member();
  }
}
inline ::Backage::MethodDecl* Declaration::release_methoddecl() {
  // @@protoc_insertion_point(field_release:Backage.Declaration.methodDecl)
  if (_internal_has_methoddecl()) {
    clear_has_Member();
    ::Backage::MethodDecl* temp = _impl_.Member_.methoddecl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Member_.methoddecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::MethodDecl& Declaration::_internal_methoddecl() const {
  return _internal_has_methoddecl()
      ? *_impl_.Member_.methoddecl_
      : reinterpret_cast< ::Backage::MethodDecl&>(::Backage::_MethodDecl_default_instance_);
}
inline const ::Backage::MethodDecl& Declaration::methoddecl() const {
  // @@protoc_insertion_point(field_get:Backage.Declaration.methodDecl)
  return _internal_methoddecl();
}
inline ::Backage::MethodDecl* Declaration::unsafe_arena_release_methoddecl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.Declaration.methodDecl)
  if (_internal_has_methoddecl()) {
    clear_has_Member();
    ::Backage::MethodDecl* temp = _impl_.Member_.methoddecl_;
    _impl_.Member_.methoddecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Declaration::unsafe_arena_set_allocated_methoddecl(::Backage::MethodDecl* methoddecl) {
  clear_Member();
  if (methoddecl) {
    set_has_methoddecl();
    _impl_.Member_.methoddecl_ = methoddecl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.Declaration.methodDecl)
}
inline ::Backage::MethodDecl* Declaration::_internal_mutable_methoddecl() {
  if (!_internal_has_methoddecl()) {
    clear_Member();
    set_has_methoddecl();
    _impl_.Member_.methoddecl_ = CreateMaybeMessage< ::Backage::MethodDecl >(GetArenaForAllocation());
  }
  return _impl_.Member_.methoddecl_;
}
inline ::Backage::MethodDecl* Declaration::mutable_methoddecl() {
  ::Backage::MethodDecl* _msg = _internal_mutable_methoddecl();
  // @@protoc_insertion_point(field_mutable:Backage.Declaration.methodDecl)
  return _msg;
}

// .Backage.CtorDecl ctorDecl = 8;
inline bool Declaration::_internal_has_ctordecl() const {
  return Member_case() == kCtorDecl;
}
inline bool Declaration::has_ctordecl() const {
  return _internal_has_ctordecl();
}
inline void Declaration::set_has_ctordecl() {
  _impl_._oneof_case_[0] = kCtorDecl;
}
inline void Declaration::clear_ctordecl() {
  if (_internal_has_ctordecl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Member_.ctordecl_;
    }
    clear_has_Member();
  }
}
inline ::Backage::CtorDecl* Declaration::release_ctordecl() {
  // @@protoc_insertion_point(field_release:Backage.Declaration.ctorDecl)
  if (_internal_has_ctordecl()) {
    clear_has_Member();
    ::Backage::CtorDecl* temp = _impl_.Member_.ctordecl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Member_.ctordecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::CtorDecl& Declaration::_internal_ctordecl() const {
  return _internal_has_ctordecl()
      ? *_impl_.Member_.ctordecl_
      : reinterpret_cast< ::Backage::CtorDecl&>(::Backage::_CtorDecl_default_instance_);
}
inline const ::Backage::CtorDecl& Declaration::ctordecl() const {
  // @@protoc_insertion_point(field_get:Backage.Declaration.ctorDecl)
  return _internal_ctordecl();
}
inline ::Backage::CtorDecl* Declaration::unsafe_arena_release_ctordecl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.Declaration.ctorDecl)
  if (_internal_has_ctordecl()) {
    clear_has_Member();
    ::Backage::CtorDecl* temp = _impl_.Member_.ctordecl_;
    _impl_.Member_.ctordecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Declaration::unsafe_arena_set_allocated_ctordecl(::Backage::CtorDecl* ctordecl) {
  clear_Member();
  if (ctordecl) {
    set_has_ctordecl();
    _impl_.Member_.ctordecl_ = ctordecl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.Declaration.ctorDecl)
}
inline ::Backage::CtorDecl* Declaration::_internal_mutable_ctordecl() {
  if (!_internal_has_ctordecl()) {
    clear_Member();
    set_has_ctordecl();
    _impl_.Member_.ctordecl_ = CreateMaybeMessage< ::Backage::CtorDecl >(GetArenaForAllocation());
  }
  return _impl_.Member_.ctordecl_;
}
inline ::Backage::CtorDecl* Declaration::mutable_ctordecl() {
  ::Backage::CtorDecl* _msg = _internal_mutable_ctordecl();
  // @@protoc_insertion_point(field_mutable:Backage.Declaration.ctorDecl)
  return _msg;
}

// .Backage.ForeignEntryDecl foreignEntryDecl = 9;
inline bool Declaration::_internal_has_foreignentrydecl() const {
  return Member_case() == kForeignEntryDecl;
}
inline bool Declaration::has_foreignentrydecl() const {
  return _internal_has_foreignentrydecl();
}
inline void Declaration::set_has_foreignentrydecl() {
  _impl_._oneof_case_[0] = kForeignEntryDecl;
}
inline void Declaration::clear_foreignentrydecl() {
  if (_internal_has_foreignentrydecl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Member_.foreignentrydecl_;
    }
    clear_has_Member();
  }
}
inline ::Backage::ForeignEntryDecl* Declaration::release_foreignentrydecl() {
  // @@protoc_insertion_point(field_release:Backage.Declaration.foreignEntryDecl)
  if (_internal_has_foreignentrydecl()) {
    clear_has_Member();
    ::Backage::ForeignEntryDecl* temp = _impl_.Member_.foreignentrydecl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Member_.foreignentrydecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Backage::ForeignEntryDecl& Declaration::_internal_foreignentrydecl() const {
  return _internal_has_foreignentrydecl()
      ? *_impl_.Member_.foreignentrydecl_
      : reinterpret_cast< ::Backage::ForeignEntryDecl&>(::Backage::_ForeignEntryDecl_default_instance_);
}
inline const ::Backage::ForeignEntryDecl& Declaration::foreignentrydecl() const {
  // @@protoc_insertion_point(field_get:Backage.Declaration.foreignEntryDecl)
  return _internal_foreignentrydecl();
}
inline ::Backage::ForeignEntryDecl* Declaration::unsafe_arena_release_foreignentrydecl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Backage.Declaration.foreignEntryDecl)
  if (_internal_has_foreignentrydecl()) {
    clear_has_Member();
    ::Backage::ForeignEntryDecl* temp = _impl_.Member_.foreignentrydecl_;
    _impl_.Member_.foreignentrydecl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Declaration::unsafe_arena_set_allocated_foreignentrydecl(::Backage::ForeignEntryDecl* foreignentrydecl) {
  clear_Member();
  if (foreignentrydecl) {
    set_has_foreignentrydecl();
    _impl_.Member_.foreignentrydecl_ = foreignentrydecl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Backage.Declaration.foreignEntryDecl)
}
inline ::Backage::ForeignEntryDecl* Declaration::_internal_mutable_foreignentrydecl() {
  if (!_internal_has_foreignentrydecl()) {
    clear_Member();
    set_has_foreignentrydecl();
    _impl_.Member_.foreignentrydecl_ = CreateMaybeMessage< ::Backage::ForeignEntryDecl >(GetArenaForAllocation());
  }
  return _impl_.Member_.foreignentrydecl_;
}
inline ::Backage::ForeignEntryDecl* Declaration::mutable_foreignentrydecl() {
  ::Backage::ForeignEntryDecl* _msg = _internal_mutable_foreignentrydecl();
  // @@protoc_insertion_point(field_mutable:Backage.Declaration.foreignEntryDecl)
  return _msg;
}

inline bool Declaration::has_Member() const {
  return Member_case() != MEMBER_NOT_SET;
}
inline void Declaration::clear_has_Member() {
  _impl_._oneof_case_[0] = MEMBER_NOT_SET;
}
inline Declaration::MemberCase Declaration::Member_case() const {
  return Declaration::MemberCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClassDecl

// uint32 flag = 1;
inline void ClassDecl::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t ClassDecl::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t ClassDecl::flag() const {
  // @@protoc_insertion_point(field_get:Backage.ClassDecl.flag)
  return _internal_flag();
}
inline void ClassDecl::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void ClassDecl::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:Backage.ClassDecl.flag)
}

// uint32 nameToken = 2;
inline void ClassDecl::clear_nametoken() {
  _impl_.nametoken_ = 0u;
}
inline uint32_t ClassDecl::_internal_nametoken() const {
  return _impl_.nametoken_;
}
inline uint32_t ClassDecl::nametoken() const {
  // @@protoc_insertion_point(field_get:Backage.ClassDecl.nameToken)
  return _internal_nametoken();
}
inline void ClassDecl::_internal_set_nametoken(uint32_t value) {
  
  _impl_.nametoken_ = value;
}
inline void ClassDecl::set_nametoken(uint32_t value) {
  _internal_set_nametoken(value);
  // @@protoc_insertion_point(field_set:Backage.ClassDecl.nameToken)
}

// uint32 baseToken = 3;
inline void ClassDecl::clear_basetoken() {
  _impl_.basetoken_ = 0u;
}
inline uint32_t ClassDecl::_internal_basetoken() const {
  return _impl_.basetoken_;
}
inline uint32_t ClassDecl::basetoken() const {
  // @@protoc_insertion_point(field_get:Backage.ClassDecl.baseToken)
  return _internal_basetoken();
}
inline void ClassDecl::_internal_set_basetoken(uint32_t value) {
  
  _impl_.basetoken_ = value;
}
inline void ClassDecl::set_basetoken(uint32_t value) {
  _internal_set_basetoken(value);
  // @@protoc_insertion_point(field_set:Backage.ClassDecl.baseToken)
}

// repeated uint32 implToken = 4;
inline int ClassDecl::_internal_impltoken_size() const {
  return _impl_.impltoken_.size();
}
inline int ClassDecl::impltoken_size() const {
  return _internal_impltoken_size();
}
inline void ClassDecl::clear_impltoken() {
  _impl_.impltoken_.Clear();
}
inline uint32_t ClassDecl::_internal_impltoken(int index) const {
  return _impl_.impltoken_.Get(index);
}
inline uint32_t ClassDecl::impltoken(int index) const {
  // @@protoc_insertion_point(field_get:Backage.ClassDecl.implToken)
  return _internal_impltoken(index);
}
inline void ClassDecl::set_impltoken(int index, uint32_t value) {
  _impl_.impltoken_.Set(index, value);
  // @@protoc_insertion_point(field_set:Backage.ClassDecl.implToken)
}
inline void ClassDecl::_internal_add_impltoken(uint32_t value) {
  _impl_.impltoken_.Add(value);
}
inline void ClassDecl::add_impltoken(uint32_t value) {
  _internal_add_impltoken(value);
  // @@protoc_insertion_point(field_add:Backage.ClassDecl.implToken)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ClassDecl::_internal_impltoken() const {
  return _impl_.impltoken_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ClassDecl::impltoken() const {
  // @@protoc_insertion_point(field_list:Backage.ClassDecl.implToken)
  return _internal_impltoken();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ClassDecl::_internal_mutable_impltoken() {
  return &_impl_.impltoken_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ClassDecl::mutable_impltoken() {
  // @@protoc_insertion_point(field_mutable_list:Backage.ClassDecl.implToken)
  return _internal_mutable_impltoken();
}

// repeated .Backage.Declaration declarations = 5;
inline int ClassDecl::_internal_declarations_size() const {
  return _impl_.declarations_.size();
}
inline int ClassDecl::declarations_size() const {
  return _internal_declarations_size();
}
inline void ClassDecl::clear_declarations() {
  _impl_.declarations_.Clear();
}
inline ::Backage::Declaration* ClassDecl::mutable_declarations(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.ClassDecl.declarations)
  return _impl_.declarations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >*
ClassDecl::mutable_declarations() {
  // @@protoc_insertion_point(field_mutable_list:Backage.ClassDecl.declarations)
  return &_impl_.declarations_;
}
inline const ::Backage::Declaration& ClassDecl::_internal_declarations(int index) const {
  return _impl_.declarations_.Get(index);
}
inline const ::Backage::Declaration& ClassDecl::declarations(int index) const {
  // @@protoc_insertion_point(field_get:Backage.ClassDecl.declarations)
  return _internal_declarations(index);
}
inline ::Backage::Declaration* ClassDecl::_internal_add_declarations() {
  return _impl_.declarations_.Add();
}
inline ::Backage::Declaration* ClassDecl::add_declarations() {
  ::Backage::Declaration* _add = _internal_add_declarations();
  // @@protoc_insertion_point(field_add:Backage.ClassDecl.declarations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >&
ClassDecl::declarations() const {
  // @@protoc_insertion_point(field_list:Backage.ClassDecl.declarations)
  return _impl_.declarations_;
}

// -------------------------------------------------------------------

// RecordDecl

// uint32 flag = 1;
inline void RecordDecl::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t RecordDecl::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t RecordDecl::flag() const {
  // @@protoc_insertion_point(field_get:Backage.RecordDecl.flag)
  return _internal_flag();
}
inline void RecordDecl::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void RecordDecl::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:Backage.RecordDecl.flag)
}

// uint32 nameToken = 2;
inline void RecordDecl::clear_nametoken() {
  _impl_.nametoken_ = 0u;
}
inline uint32_t RecordDecl::_internal_nametoken() const {
  return _impl_.nametoken_;
}
inline uint32_t RecordDecl::nametoken() const {
  // @@protoc_insertion_point(field_get:Backage.RecordDecl.nameToken)
  return _internal_nametoken();
}
inline void RecordDecl::_internal_set_nametoken(uint32_t value) {
  
  _impl_.nametoken_ = value;
}
inline void RecordDecl::set_nametoken(uint32_t value) {
  _internal_set_nametoken(value);
  // @@protoc_insertion_point(field_set:Backage.RecordDecl.nameToken)
}

// repeated .Backage.Declaration declarations = 3;
inline int RecordDecl::_internal_declarations_size() const {
  return _impl_.declarations_.size();
}
inline int RecordDecl::declarations_size() const {
  return _internal_declarations_size();
}
inline void RecordDecl::clear_declarations() {
  _impl_.declarations_.Clear();
}
inline ::Backage::Declaration* RecordDecl::mutable_declarations(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.RecordDecl.declarations)
  return _impl_.declarations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >*
RecordDecl::mutable_declarations() {
  // @@protoc_insertion_point(field_mutable_list:Backage.RecordDecl.declarations)
  return &_impl_.declarations_;
}
inline const ::Backage::Declaration& RecordDecl::_internal_declarations(int index) const {
  return _impl_.declarations_.Get(index);
}
inline const ::Backage::Declaration& RecordDecl::declarations(int index) const {
  // @@protoc_insertion_point(field_get:Backage.RecordDecl.declarations)
  return _internal_declarations(index);
}
inline ::Backage::Declaration* RecordDecl::_internal_add_declarations() {
  return _impl_.declarations_.Add();
}
inline ::Backage::Declaration* RecordDecl::add_declarations() {
  ::Backage::Declaration* _add = _internal_add_declarations();
  // @@protoc_insertion_point(field_add:Backage.RecordDecl.declarations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >&
RecordDecl::declarations() const {
  // @@protoc_insertion_point(field_list:Backage.RecordDecl.declarations)
  return _impl_.declarations_;
}

// -------------------------------------------------------------------

// EnumDecl

// uint32 flag = 1;
inline void EnumDecl::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t EnumDecl::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t EnumDecl::flag() const {
  // @@protoc_insertion_point(field_get:Backage.EnumDecl.flag)
  return _internal_flag();
}
inline void EnumDecl::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void EnumDecl::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:Backage.EnumDecl.flag)
}

// uint32 nameToken = 2;
inline void EnumDecl::clear_nametoken() {
  _impl_.nametoken_ = 0u;
}
inline uint32_t EnumDecl::_internal_nametoken() const {
  return _impl_.nametoken_;
}
inline uint32_t EnumDecl::nametoken() const {
  // @@protoc_insertion_point(field_get:Backage.EnumDecl.nameToken)
  return _internal_nametoken();
}
inline void EnumDecl::_internal_set_nametoken(uint32_t value) {
  
  _impl_.nametoken_ = value;
}
inline void EnumDecl::set_nametoken(uint32_t value) {
  _internal_set_nametoken(value);
  // @@protoc_insertion_point(field_set:Backage.EnumDecl.nameToken)
}

// repeated .Backage.EnumConstant constants = 3;
inline int EnumDecl::_internal_constants_size() const {
  return _impl_.constants_.size();
}
inline int EnumDecl::constants_size() const {
  return _internal_constants_size();
}
inline void EnumDecl::clear_constants() {
  _impl_.constants_.Clear();
}
inline ::Backage::EnumConstant* EnumDecl::mutable_constants(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.EnumDecl.constants)
  return _impl_.constants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::EnumConstant >*
EnumDecl::mutable_constants() {
  // @@protoc_insertion_point(field_mutable_list:Backage.EnumDecl.constants)
  return &_impl_.constants_;
}
inline const ::Backage::EnumConstant& EnumDecl::_internal_constants(int index) const {
  return _impl_.constants_.Get(index);
}
inline const ::Backage::EnumConstant& EnumDecl::constants(int index) const {
  // @@protoc_insertion_point(field_get:Backage.EnumDecl.constants)
  return _internal_constants(index);
}
inline ::Backage::EnumConstant* EnumDecl::_internal_add_constants() {
  return _impl_.constants_.Add();
}
inline ::Backage::EnumConstant* EnumDecl::add_constants() {
  ::Backage::EnumConstant* _add = _internal_add_constants();
  // @@protoc_insertion_point(field_add:Backage.EnumDecl.constants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::EnumConstant >&
EnumDecl::constants() const {
  // @@protoc_insertion_point(field_list:Backage.EnumDecl.constants)
  return _impl_.constants_;
}

// -------------------------------------------------------------------

// EnumConstant

// uint32 nameToken = 1;
inline void EnumConstant::clear_nametoken() {
  _impl_.nametoken_ = 0u;
}
inline uint32_t EnumConstant::_internal_nametoken() const {
  return _impl_.nametoken_;
}
inline uint32_t EnumConstant::nametoken() const {
  // @@protoc_insertion_point(field_get:Backage.EnumConstant.nameToken)
  return _internal_nametoken();
}
inline void EnumConstant::_internal_set_nametoken(uint32_t value) {
  
  _impl_.nametoken_ = value;
}
inline void EnumConstant::set_nametoken(uint32_t value) {
  _internal_set_nametoken(value);
  // @@protoc_insertion_point(field_set:Backage.EnumConstant.nameToken)
}

// uint32 value = 2;
inline void EnumConstant::clear_value() {
  _impl_.value_ = 0u;
}
inline uint32_t EnumConstant::_internal_value() const {
  return _impl_.value_;
}
inline uint32_t EnumConstant::value() const {
  // @@protoc_insertion_point(field_get:Backage.EnumConstant.value)
  return _internal_value();
}
inline void EnumConstant::_internal_set_value(uint32_t value) {
  
  _impl_.value_ = value;
}
inline void EnumConstant::set_value(uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Backage.EnumConstant.value)
}

// -------------------------------------------------------------------

// VariableDecl

// uint32 flag = 1;
inline void VariableDecl::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t VariableDecl::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t VariableDecl::flag() const {
  // @@protoc_insertion_point(field_get:Backage.VariableDecl.flag)
  return _internal_flag();
}
inline void VariableDecl::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void VariableDecl::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:Backage.VariableDecl.flag)
}

// uint32 nameToken = 2;
inline void VariableDecl::clear_nametoken() {
  _impl_.nametoken_ = 0u;
}
inline uint32_t VariableDecl::_internal_nametoken() const {
  return _impl_.nametoken_;
}
inline uint32_t VariableDecl::nametoken() const {
  // @@protoc_insertion_point(field_get:Backage.VariableDecl.nameToken)
  return _internal_nametoken();
}
inline void VariableDecl::_internal_set_nametoken(uint32_t value) {
  
  _impl_.nametoken_ = value;
}
inline void VariableDecl::set_nametoken(uint32_t value) {
  _internal_set_nametoken(value);
  // @@protoc_insertion_point(field_set:Backage.VariableDecl.nameToken)
}

// uint32 typeToken = 3;
inline void VariableDecl::clear_typetoken() {
  _impl_.typetoken_ = 0u;
}
inline uint32_t VariableDecl::_internal_typetoken() const {
  return _impl_.typetoken_;
}
inline uint32_t VariableDecl::typetoken() const {
  // @@protoc_insertion_point(field_get:Backage.VariableDecl.typeToken)
  return _internal_typetoken();
}
inline void VariableDecl::_internal_set_typetoken(uint32_t value) {
  
  _impl_.typetoken_ = value;
}
inline void VariableDecl::set_typetoken(uint32_t value) {
  _internal_set_typetoken(value);
  // @@protoc_insertion_point(field_set:Backage.VariableDecl.typeToken)
}

// optional bytes initial = 4;
inline bool VariableDecl::_internal_has_initial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VariableDecl::has_initial() const {
  return _internal_has_initial();
}
inline void VariableDecl::clear_initial() {
  _impl_.initial_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VariableDecl::initial() const {
  // @@protoc_insertion_point(field_get:Backage.VariableDecl.initial)
  return _internal_initial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VariableDecl::set_initial(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.initial_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.VariableDecl.initial)
}
inline std::string* VariableDecl::mutable_initial() {
  std::string* _s = _internal_mutable_initial();
  // @@protoc_insertion_point(field_mutable:Backage.VariableDecl.initial)
  return _s;
}
inline const std::string& VariableDecl::_internal_initial() const {
  return _impl_.initial_.Get();
}
inline void VariableDecl::_internal_set_initial(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.initial_.Set(value, GetArenaForAllocation());
}
inline std::string* VariableDecl::_internal_mutable_initial() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.initial_.Mutable(GetArenaForAllocation());
}
inline std::string* VariableDecl::release_initial() {
  // @@protoc_insertion_point(field_release:Backage.VariableDecl.initial)
  if (!_internal_has_initial()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.initial_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initial_.IsDefault()) {
    _impl_.initial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VariableDecl::set_allocated_initial(std::string* initial) {
  if (initial != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.initial_.SetAllocated(initial, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initial_.IsDefault()) {
    _impl_.initial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.VariableDecl.initial)
}

// -------------------------------------------------------------------

// ParameterDecl

// uint32 flag = 1;
inline void ParameterDecl::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t ParameterDecl::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t ParameterDecl::flag() const {
  // @@protoc_insertion_point(field_get:Backage.ParameterDecl.flag)
  return _internal_flag();
}
inline void ParameterDecl::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void ParameterDecl::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:Backage.ParameterDecl.flag)
}

// uint32 nameToken = 2;
inline void ParameterDecl::clear_nametoken() {
  _impl_.nametoken_ = 0u;
}
inline uint32_t ParameterDecl::_internal_nametoken() const {
  return _impl_.nametoken_;
}
inline uint32_t ParameterDecl::nametoken() const {
  // @@protoc_insertion_point(field_get:Backage.ParameterDecl.nameToken)
  return _internal_nametoken();
}
inline void ParameterDecl::_internal_set_nametoken(uint32_t value) {
  
  _impl_.nametoken_ = value;
}
inline void ParameterDecl::set_nametoken(uint32_t value) {
  _internal_set_nametoken(value);
  // @@protoc_insertion_point(field_set:Backage.ParameterDecl.nameToken)
}

// uint32 typeToken = 3;
inline void ParameterDecl::clear_typetoken() {
  _impl_.typetoken_ = 0u;
}
inline uint32_t ParameterDecl::_internal_typetoken() const {
  return _impl_.typetoken_;
}
inline uint32_t ParameterDecl::typetoken() const {
  // @@protoc_insertion_point(field_get:Backage.ParameterDecl.typeToken)
  return _internal_typetoken();
}
inline void ParameterDecl::_internal_set_typetoken(uint32_t value) {
  
  _impl_.typetoken_ = value;
}
inline void ParameterDecl::set_typetoken(uint32_t value) {
  _internal_set_typetoken(value);
  // @@protoc_insertion_point(field_set:Backage.ParameterDecl.typeToken)
}

// optional bytes initial = 4;
inline bool ParameterDecl::_internal_has_initial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParameterDecl::has_initial() const {
  return _internal_has_initial();
}
inline void ParameterDecl::clear_initial() {
  _impl_.initial_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParameterDecl::initial() const {
  // @@protoc_insertion_point(field_get:Backage.ParameterDecl.initial)
  return _internal_initial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParameterDecl::set_initial(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.initial_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.ParameterDecl.initial)
}
inline std::string* ParameterDecl::mutable_initial() {
  std::string* _s = _internal_mutable_initial();
  // @@protoc_insertion_point(field_mutable:Backage.ParameterDecl.initial)
  return _s;
}
inline const std::string& ParameterDecl::_internal_initial() const {
  return _impl_.initial_.Get();
}
inline void ParameterDecl::_internal_set_initial(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.initial_.Set(value, GetArenaForAllocation());
}
inline std::string* ParameterDecl::_internal_mutable_initial() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.initial_.Mutable(GetArenaForAllocation());
}
inline std::string* ParameterDecl::release_initial() {
  // @@protoc_insertion_point(field_release:Backage.ParameterDecl.initial)
  if (!_internal_has_initial()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.initial_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initial_.IsDefault()) {
    _impl_.initial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ParameterDecl::set_allocated_initial(std::string* initial) {
  if (initial != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.initial_.SetAllocated(initial, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initial_.IsDefault()) {
    _impl_.initial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.ParameterDecl.initial)
}

// -------------------------------------------------------------------

// ModuleDecl

// uint32 flag = 1;
inline void ModuleDecl::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t ModuleDecl::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t ModuleDecl::flag() const {
  // @@protoc_insertion_point(field_get:Backage.ModuleDecl.flag)
  return _internal_flag();
}
inline void ModuleDecl::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void ModuleDecl::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:Backage.ModuleDecl.flag)
}

// uint32 nameToken = 2;
inline void ModuleDecl::clear_nametoken() {
  _impl_.nametoken_ = 0u;
}
inline uint32_t ModuleDecl::_internal_nametoken() const {
  return _impl_.nametoken_;
}
inline uint32_t ModuleDecl::nametoken() const {
  // @@protoc_insertion_point(field_get:Backage.ModuleDecl.nameToken)
  return _internal_nametoken();
}
inline void ModuleDecl::_internal_set_nametoken(uint32_t value) {
  
  _impl_.nametoken_ = value;
}
inline void ModuleDecl::set_nametoken(uint32_t value) {
  _internal_set_nametoken(value);
  // @@protoc_insertion_point(field_set:Backage.ModuleDecl.nameToken)
}

// repeated .Backage.Declaration declarations = 3;
inline int ModuleDecl::_internal_declarations_size() const {
  return _impl_.declarations_.size();
}
inline int ModuleDecl::declarations_size() const {
  return _internal_declarations_size();
}
inline void ModuleDecl::clear_declarations() {
  _impl_.declarations_.Clear();
}
inline ::Backage::Declaration* ModuleDecl::mutable_declarations(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.ModuleDecl.declarations)
  return _impl_.declarations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >*
ModuleDecl::mutable_declarations() {
  // @@protoc_insertion_point(field_mutable_list:Backage.ModuleDecl.declarations)
  return &_impl_.declarations_;
}
inline const ::Backage::Declaration& ModuleDecl::_internal_declarations(int index) const {
  return _impl_.declarations_.Get(index);
}
inline const ::Backage::Declaration& ModuleDecl::declarations(int index) const {
  // @@protoc_insertion_point(field_get:Backage.ModuleDecl.declarations)
  return _internal_declarations(index);
}
inline ::Backage::Declaration* ModuleDecl::_internal_add_declarations() {
  return _impl_.declarations_.Add();
}
inline ::Backage::Declaration* ModuleDecl::add_declarations() {
  ::Backage::Declaration* _add = _internal_add_declarations();
  // @@protoc_insertion_point(field_add:Backage.ModuleDecl.declarations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::Declaration >&
ModuleDecl::declarations() const {
  // @@protoc_insertion_point(field_list:Backage.ModuleDecl.declarations)
  return _impl_.declarations_;
}

// -------------------------------------------------------------------

// LocalIndex

// uint32 id = 1;
inline void LocalIndex::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t LocalIndex::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t LocalIndex::id() const {
  // @@protoc_insertion_point(field_get:Backage.LocalIndex.id)
  return _internal_id();
}
inline void LocalIndex::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void LocalIndex::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Backage.LocalIndex.id)
}

// uint32 typeToken = 2;
inline void LocalIndex::clear_typetoken() {
  _impl_.typetoken_ = 0u;
}
inline uint32_t LocalIndex::_internal_typetoken() const {
  return _impl_.typetoken_;
}
inline uint32_t LocalIndex::typetoken() const {
  // @@protoc_insertion_point(field_get:Backage.LocalIndex.typeToken)
  return _internal_typetoken();
}
inline void LocalIndex::_internal_set_typetoken(uint32_t value) {
  
  _impl_.typetoken_ = value;
}
inline void LocalIndex::set_typetoken(uint32_t value) {
  _internal_set_typetoken(value);
  // @@protoc_insertion_point(field_set:Backage.LocalIndex.typeToken)
}

// -------------------------------------------------------------------

// MethodDecl

// uint32 flag = 1;
inline void MethodDecl::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t MethodDecl::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t MethodDecl::flag() const {
  // @@protoc_insertion_point(field_get:Backage.MethodDecl.flag)
  return _internal_flag();
}
inline void MethodDecl::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void MethodDecl::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:Backage.MethodDecl.flag)
}

// uint32 nameToken = 2;
inline void MethodDecl::clear_nametoken() {
  _impl_.nametoken_ = 0u;
}
inline uint32_t MethodDecl::_internal_nametoken() const {
  return _impl_.nametoken_;
}
inline uint32_t MethodDecl::nametoken() const {
  // @@protoc_insertion_point(field_get:Backage.MethodDecl.nameToken)
  return _internal_nametoken();
}
inline void MethodDecl::_internal_set_nametoken(uint32_t value) {
  
  _impl_.nametoken_ = value;
}
inline void MethodDecl::set_nametoken(uint32_t value) {
  _internal_set_nametoken(value);
  // @@protoc_insertion_point(field_set:Backage.MethodDecl.nameToken)
}

// repeated .Backage.ParameterDecl params = 3;
inline int MethodDecl::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int MethodDecl::params_size() const {
  return _internal_params_size();
}
inline void MethodDecl::clear_params() {
  _impl_.params_.Clear();
}
inline ::Backage::ParameterDecl* MethodDecl::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.MethodDecl.params)
  return _impl_.params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >*
MethodDecl::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Backage.MethodDecl.params)
  return &_impl_.params_;
}
inline const ::Backage::ParameterDecl& MethodDecl::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const ::Backage::ParameterDecl& MethodDecl::params(int index) const {
  // @@protoc_insertion_point(field_get:Backage.MethodDecl.params)
  return _internal_params(index);
}
inline ::Backage::ParameterDecl* MethodDecl::_internal_add_params() {
  return _impl_.params_.Add();
}
inline ::Backage::ParameterDecl* MethodDecl::add_params() {
  ::Backage::ParameterDecl* _add = _internal_add_params();
  // @@protoc_insertion_point(field_add:Backage.MethodDecl.params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >&
MethodDecl::params() const {
  // @@protoc_insertion_point(field_list:Backage.MethodDecl.params)
  return _impl_.params_;
}

// uint32 retTypeToken = 4;
inline void MethodDecl::clear_rettypetoken() {
  _impl_.rettypetoken_ = 0u;
}
inline uint32_t MethodDecl::_internal_rettypetoken() const {
  return _impl_.rettypetoken_;
}
inline uint32_t MethodDecl::rettypetoken() const {
  // @@protoc_insertion_point(field_get:Backage.MethodDecl.retTypeToken)
  return _internal_rettypetoken();
}
inline void MethodDecl::_internal_set_rettypetoken(uint32_t value) {
  
  _impl_.rettypetoken_ = value;
}
inline void MethodDecl::set_rettypetoken(uint32_t value) {
  _internal_set_rettypetoken(value);
  // @@protoc_insertion_point(field_set:Backage.MethodDecl.retTypeToken)
}

// repeated .Backage.LocalIndex localIndex = 5;
inline int MethodDecl::_internal_localindex_size() const {
  return _impl_.localindex_.size();
}
inline int MethodDecl::localindex_size() const {
  return _internal_localindex_size();
}
inline void MethodDecl::clear_localindex() {
  _impl_.localindex_.Clear();
}
inline ::Backage::LocalIndex* MethodDecl::mutable_localindex(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.MethodDecl.localIndex)
  return _impl_.localindex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex >*
MethodDecl::mutable_localindex() {
  // @@protoc_insertion_point(field_mutable_list:Backage.MethodDecl.localIndex)
  return &_impl_.localindex_;
}
inline const ::Backage::LocalIndex& MethodDecl::_internal_localindex(int index) const {
  return _impl_.localindex_.Get(index);
}
inline const ::Backage::LocalIndex& MethodDecl::localindex(int index) const {
  // @@protoc_insertion_point(field_get:Backage.MethodDecl.localIndex)
  return _internal_localindex(index);
}
inline ::Backage::LocalIndex* MethodDecl::_internal_add_localindex() {
  return _impl_.localindex_.Add();
}
inline ::Backage::LocalIndex* MethodDecl::add_localindex() {
  ::Backage::LocalIndex* _add = _internal_add_localindex();
  // @@protoc_insertion_point(field_add:Backage.MethodDecl.localIndex)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex >&
MethodDecl::localindex() const {
  // @@protoc_insertion_point(field_list:Backage.MethodDecl.localIndex)
  return _impl_.localindex_;
}

// bytes block = 6;
inline void MethodDecl::clear_block() {
  _impl_.block_.ClearToEmpty();
}
inline const std::string& MethodDecl::block() const {
  // @@protoc_insertion_point(field_get:Backage.MethodDecl.block)
  return _internal_block();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MethodDecl::set_block(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.MethodDecl.block)
}
inline std::string* MethodDecl::mutable_block() {
  std::string* _s = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:Backage.MethodDecl.block)
  return _s;
}
inline const std::string& MethodDecl::_internal_block() const {
  return _impl_.block_.Get();
}
inline void MethodDecl::_internal_set_block(const std::string& value) {
  
  _impl_.block_.Set(value, GetArenaForAllocation());
}
inline std::string* MethodDecl::_internal_mutable_block() {
  
  return _impl_.block_.Mutable(GetArenaForAllocation());
}
inline std::string* MethodDecl::release_block() {
  // @@protoc_insertion_point(field_release:Backage.MethodDecl.block)
  return _impl_.block_.Release();
}
inline void MethodDecl::set_allocated_block(std::string* block) {
  if (block != nullptr) {
    
  } else {
    
  }
  _impl_.block_.SetAllocated(block, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_.IsDefault()) {
    _impl_.block_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.MethodDecl.block)
}

// repeated .Backage.LineNumber lineNumbers = 7;
inline int MethodDecl::_internal_linenumbers_size() const {
  return _impl_.linenumbers_.size();
}
inline int MethodDecl::linenumbers_size() const {
  return _internal_linenumbers_size();
}
inline void MethodDecl::clear_linenumbers() {
  _impl_.linenumbers_.Clear();
}
inline ::Backage::LineNumber* MethodDecl::mutable_linenumbers(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.MethodDecl.lineNumbers)
  return _impl_.linenumbers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber >*
MethodDecl::mutable_linenumbers() {
  // @@protoc_insertion_point(field_mutable_list:Backage.MethodDecl.lineNumbers)
  return &_impl_.linenumbers_;
}
inline const ::Backage::LineNumber& MethodDecl::_internal_linenumbers(int index) const {
  return _impl_.linenumbers_.Get(index);
}
inline const ::Backage::LineNumber& MethodDecl::linenumbers(int index) const {
  // @@protoc_insertion_point(field_get:Backage.MethodDecl.lineNumbers)
  return _internal_linenumbers(index);
}
inline ::Backage::LineNumber* MethodDecl::_internal_add_linenumbers() {
  return _impl_.linenumbers_.Add();
}
inline ::Backage::LineNumber* MethodDecl::add_linenumbers() {
  ::Backage::LineNumber* _add = _internal_add_linenumbers();
  // @@protoc_insertion_point(field_add:Backage.MethodDecl.lineNumbers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber >&
MethodDecl::linenumbers() const {
  // @@protoc_insertion_point(field_list:Backage.MethodDecl.lineNumbers)
  return _impl_.linenumbers_;
}

// repeated .Backage.ExceptionEntry exceptionEntry = 8;
inline int MethodDecl::_internal_exceptionentry_size() const {
  return _impl_.exceptionentry_.size();
}
inline int MethodDecl::exceptionentry_size() const {
  return _internal_exceptionentry_size();
}
inline void MethodDecl::clear_exceptionentry() {
  _impl_.exceptionentry_.Clear();
}
inline ::Backage::ExceptionEntry* MethodDecl::mutable_exceptionentry(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.MethodDecl.exceptionEntry)
  return _impl_.exceptionentry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry >*
MethodDecl::mutable_exceptionentry() {
  // @@protoc_insertion_point(field_mutable_list:Backage.MethodDecl.exceptionEntry)
  return &_impl_.exceptionentry_;
}
inline const ::Backage::ExceptionEntry& MethodDecl::_internal_exceptionentry(int index) const {
  return _impl_.exceptionentry_.Get(index);
}
inline const ::Backage::ExceptionEntry& MethodDecl::exceptionentry(int index) const {
  // @@protoc_insertion_point(field_get:Backage.MethodDecl.exceptionEntry)
  return _internal_exceptionentry(index);
}
inline ::Backage::ExceptionEntry* MethodDecl::_internal_add_exceptionentry() {
  return _impl_.exceptionentry_.Add();
}
inline ::Backage::ExceptionEntry* MethodDecl::add_exceptionentry() {
  ::Backage::ExceptionEntry* _add = _internal_add_exceptionentry();
  // @@protoc_insertion_point(field_add:Backage.MethodDecl.exceptionEntry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry >&
MethodDecl::exceptionentry() const {
  // @@protoc_insertion_point(field_list:Backage.MethodDecl.exceptionEntry)
  return _impl_.exceptionentry_;
}

// -------------------------------------------------------------------

// CtorDecl

// uint32 flag = 1;
inline void CtorDecl::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t CtorDecl::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t CtorDecl::flag() const {
  // @@protoc_insertion_point(field_get:Backage.CtorDecl.flag)
  return _internal_flag();
}
inline void CtorDecl::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void CtorDecl::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:Backage.CtorDecl.flag)
}

// repeated .Backage.ParameterDecl params = 2;
inline int CtorDecl::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int CtorDecl::params_size() const {
  return _internal_params_size();
}
inline void CtorDecl::clear_params() {
  _impl_.params_.Clear();
}
inline ::Backage::ParameterDecl* CtorDecl::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.CtorDecl.params)
  return _impl_.params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >*
CtorDecl::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Backage.CtorDecl.params)
  return &_impl_.params_;
}
inline const ::Backage::ParameterDecl& CtorDecl::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const ::Backage::ParameterDecl& CtorDecl::params(int index) const {
  // @@protoc_insertion_point(field_get:Backage.CtorDecl.params)
  return _internal_params(index);
}
inline ::Backage::ParameterDecl* CtorDecl::_internal_add_params() {
  return _impl_.params_.Add();
}
inline ::Backage::ParameterDecl* CtorDecl::add_params() {
  ::Backage::ParameterDecl* _add = _internal_add_params();
  // @@protoc_insertion_point(field_add:Backage.CtorDecl.params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >&
CtorDecl::params() const {
  // @@protoc_insertion_point(field_list:Backage.CtorDecl.params)
  return _impl_.params_;
}

// repeated .Backage.LocalIndex localIndex = 3;
inline int CtorDecl::_internal_localindex_size() const {
  return _impl_.localindex_.size();
}
inline int CtorDecl::localindex_size() const {
  return _internal_localindex_size();
}
inline void CtorDecl::clear_localindex() {
  _impl_.localindex_.Clear();
}
inline ::Backage::LocalIndex* CtorDecl::mutable_localindex(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.CtorDecl.localIndex)
  return _impl_.localindex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex >*
CtorDecl::mutable_localindex() {
  // @@protoc_insertion_point(field_mutable_list:Backage.CtorDecl.localIndex)
  return &_impl_.localindex_;
}
inline const ::Backage::LocalIndex& CtorDecl::_internal_localindex(int index) const {
  return _impl_.localindex_.Get(index);
}
inline const ::Backage::LocalIndex& CtorDecl::localindex(int index) const {
  // @@protoc_insertion_point(field_get:Backage.CtorDecl.localIndex)
  return _internal_localindex(index);
}
inline ::Backage::LocalIndex* CtorDecl::_internal_add_localindex() {
  return _impl_.localindex_.Add();
}
inline ::Backage::LocalIndex* CtorDecl::add_localindex() {
  ::Backage::LocalIndex* _add = _internal_add_localindex();
  // @@protoc_insertion_point(field_add:Backage.CtorDecl.localIndex)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LocalIndex >&
CtorDecl::localindex() const {
  // @@protoc_insertion_point(field_list:Backage.CtorDecl.localIndex)
  return _impl_.localindex_;
}

// bytes block = 4;
inline void CtorDecl::clear_block() {
  _impl_.block_.ClearToEmpty();
}
inline const std::string& CtorDecl::block() const {
  // @@protoc_insertion_point(field_get:Backage.CtorDecl.block)
  return _internal_block();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CtorDecl::set_block(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.CtorDecl.block)
}
inline std::string* CtorDecl::mutable_block() {
  std::string* _s = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:Backage.CtorDecl.block)
  return _s;
}
inline const std::string& CtorDecl::_internal_block() const {
  return _impl_.block_.Get();
}
inline void CtorDecl::_internal_set_block(const std::string& value) {
  
  _impl_.block_.Set(value, GetArenaForAllocation());
}
inline std::string* CtorDecl::_internal_mutable_block() {
  
  return _impl_.block_.Mutable(GetArenaForAllocation());
}
inline std::string* CtorDecl::release_block() {
  // @@protoc_insertion_point(field_release:Backage.CtorDecl.block)
  return _impl_.block_.Release();
}
inline void CtorDecl::set_allocated_block(std::string* block) {
  if (block != nullptr) {
    
  } else {
    
  }
  _impl_.block_.SetAllocated(block, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_.IsDefault()) {
    _impl_.block_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.CtorDecl.block)
}

// repeated .Backage.LineNumber lineNumbers = 5;
inline int CtorDecl::_internal_linenumbers_size() const {
  return _impl_.linenumbers_.size();
}
inline int CtorDecl::linenumbers_size() const {
  return _internal_linenumbers_size();
}
inline void CtorDecl::clear_linenumbers() {
  _impl_.linenumbers_.Clear();
}
inline ::Backage::LineNumber* CtorDecl::mutable_linenumbers(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.CtorDecl.lineNumbers)
  return _impl_.linenumbers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber >*
CtorDecl::mutable_linenumbers() {
  // @@protoc_insertion_point(field_mutable_list:Backage.CtorDecl.lineNumbers)
  return &_impl_.linenumbers_;
}
inline const ::Backage::LineNumber& CtorDecl::_internal_linenumbers(int index) const {
  return _impl_.linenumbers_.Get(index);
}
inline const ::Backage::LineNumber& CtorDecl::linenumbers(int index) const {
  // @@protoc_insertion_point(field_get:Backage.CtorDecl.lineNumbers)
  return _internal_linenumbers(index);
}
inline ::Backage::LineNumber* CtorDecl::_internal_add_linenumbers() {
  return _impl_.linenumbers_.Add();
}
inline ::Backage::LineNumber* CtorDecl::add_linenumbers() {
  ::Backage::LineNumber* _add = _internal_add_linenumbers();
  // @@protoc_insertion_point(field_add:Backage.CtorDecl.lineNumbers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::LineNumber >&
CtorDecl::linenumbers() const {
  // @@protoc_insertion_point(field_list:Backage.CtorDecl.lineNumbers)
  return _impl_.linenumbers_;
}

// repeated .Backage.ExceptionEntry exceptionEntry = 6;
inline int CtorDecl::_internal_exceptionentry_size() const {
  return _impl_.exceptionentry_.size();
}
inline int CtorDecl::exceptionentry_size() const {
  return _internal_exceptionentry_size();
}
inline void CtorDecl::clear_exceptionentry() {
  _impl_.exceptionentry_.Clear();
}
inline ::Backage::ExceptionEntry* CtorDecl::mutable_exceptionentry(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.CtorDecl.exceptionEntry)
  return _impl_.exceptionentry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry >*
CtorDecl::mutable_exceptionentry() {
  // @@protoc_insertion_point(field_mutable_list:Backage.CtorDecl.exceptionEntry)
  return &_impl_.exceptionentry_;
}
inline const ::Backage::ExceptionEntry& CtorDecl::_internal_exceptionentry(int index) const {
  return _impl_.exceptionentry_.Get(index);
}
inline const ::Backage::ExceptionEntry& CtorDecl::exceptionentry(int index) const {
  // @@protoc_insertion_point(field_get:Backage.CtorDecl.exceptionEntry)
  return _internal_exceptionentry(index);
}
inline ::Backage::ExceptionEntry* CtorDecl::_internal_add_exceptionentry() {
  return _impl_.exceptionentry_.Add();
}
inline ::Backage::ExceptionEntry* CtorDecl::add_exceptionentry() {
  ::Backage::ExceptionEntry* _add = _internal_add_exceptionentry();
  // @@protoc_insertion_point(field_add:Backage.CtorDecl.exceptionEntry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ExceptionEntry >&
CtorDecl::exceptionentry() const {
  // @@protoc_insertion_point(field_list:Backage.CtorDecl.exceptionEntry)
  return _impl_.exceptionentry_;
}

// -------------------------------------------------------------------

// ForeignEntryDecl

// uint32 flag = 1;
inline void ForeignEntryDecl::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t ForeignEntryDecl::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t ForeignEntryDecl::flag() const {
  // @@protoc_insertion_point(field_get:Backage.ForeignEntryDecl.flag)
  return _internal_flag();
}
inline void ForeignEntryDecl::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void ForeignEntryDecl::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:Backage.ForeignEntryDecl.flag)
}

// uint32 nameToken = 2;
inline void ForeignEntryDecl::clear_nametoken() {
  _impl_.nametoken_ = 0u;
}
inline uint32_t ForeignEntryDecl::_internal_nametoken() const {
  return _impl_.nametoken_;
}
inline uint32_t ForeignEntryDecl::nametoken() const {
  // @@protoc_insertion_point(field_get:Backage.ForeignEntryDecl.nameToken)
  return _internal_nametoken();
}
inline void ForeignEntryDecl::_internal_set_nametoken(uint32_t value) {
  
  _impl_.nametoken_ = value;
}
inline void ForeignEntryDecl::set_nametoken(uint32_t value) {
  _internal_set_nametoken(value);
  // @@protoc_insertion_point(field_set:Backage.ForeignEntryDecl.nameToken)
}

// repeated .Backage.ParameterDecl params = 3;
inline int ForeignEntryDecl::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int ForeignEntryDecl::params_size() const {
  return _internal_params_size();
}
inline void ForeignEntryDecl::clear_params() {
  _impl_.params_.Clear();
}
inline ::Backage::ParameterDecl* ForeignEntryDecl::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Backage.ForeignEntryDecl.params)
  return _impl_.params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >*
ForeignEntryDecl::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Backage.ForeignEntryDecl.params)
  return &_impl_.params_;
}
inline const ::Backage::ParameterDecl& ForeignEntryDecl::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const ::Backage::ParameterDecl& ForeignEntryDecl::params(int index) const {
  // @@protoc_insertion_point(field_get:Backage.ForeignEntryDecl.params)
  return _internal_params(index);
}
inline ::Backage::ParameterDecl* ForeignEntryDecl::_internal_add_params() {
  return _impl_.params_.Add();
}
inline ::Backage::ParameterDecl* ForeignEntryDecl::add_params() {
  ::Backage::ParameterDecl* _add = _internal_add_params();
  // @@protoc_insertion_point(field_add:Backage.ForeignEntryDecl.params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Backage::ParameterDecl >&
ForeignEntryDecl::params() const {
  // @@protoc_insertion_point(field_list:Backage.ForeignEntryDecl.params)
  return _impl_.params_;
}

// uint32 retTypeToken = 4;
inline void ForeignEntryDecl::clear_rettypetoken() {
  _impl_.rettypetoken_ = 0u;
}
inline uint32_t ForeignEntryDecl::_internal_rettypetoken() const {
  return _impl_.rettypetoken_;
}
inline uint32_t ForeignEntryDecl::rettypetoken() const {
  // @@protoc_insertion_point(field_get:Backage.ForeignEntryDecl.retTypeToken)
  return _internal_rettypetoken();
}
inline void ForeignEntryDecl::_internal_set_rettypetoken(uint32_t value) {
  
  _impl_.rettypetoken_ = value;
}
inline void ForeignEntryDecl::set_rettypetoken(uint32_t value) {
  _internal_set_rettypetoken(value);
  // @@protoc_insertion_point(field_set:Backage.ForeignEntryDecl.retTypeToken)
}

// bytes block = 5;
inline void ForeignEntryDecl::clear_block() {
  _impl_.block_.ClearToEmpty();
}
inline const std::string& ForeignEntryDecl::block() const {
  // @@protoc_insertion_point(field_get:Backage.ForeignEntryDecl.block)
  return _internal_block();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForeignEntryDecl::set_block(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.ForeignEntryDecl.block)
}
inline std::string* ForeignEntryDecl::mutable_block() {
  std::string* _s = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:Backage.ForeignEntryDecl.block)
  return _s;
}
inline const std::string& ForeignEntryDecl::_internal_block() const {
  return _impl_.block_.Get();
}
inline void ForeignEntryDecl::_internal_set_block(const std::string& value) {
  
  _impl_.block_.Set(value, GetArenaForAllocation());
}
inline std::string* ForeignEntryDecl::_internal_mutable_block() {
  
  return _impl_.block_.Mutable(GetArenaForAllocation());
}
inline std::string* ForeignEntryDecl::release_block() {
  // @@protoc_insertion_point(field_release:Backage.ForeignEntryDecl.block)
  return _impl_.block_.Release();
}
inline void ForeignEntryDecl::set_allocated_block(std::string* block) {
  if (block != nullptr) {
    
  } else {
    
  }
  _impl_.block_.SetAllocated(block, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_.IsDefault()) {
    _impl_.block_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.ForeignEntryDecl.block)
}

// optional bytes lib = 6;
inline bool ForeignEntryDecl::_internal_has_lib() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ForeignEntryDecl::has_lib() const {
  return _internal_has_lib();
}
inline void ForeignEntryDecl::clear_lib() {
  _impl_.lib_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ForeignEntryDecl::lib() const {
  // @@protoc_insertion_point(field_get:Backage.ForeignEntryDecl.lib)
  return _internal_lib();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForeignEntryDecl::set_lib(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.lib_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.ForeignEntryDecl.lib)
}
inline std::string* ForeignEntryDecl::mutable_lib() {
  std::string* _s = _internal_mutable_lib();
  // @@protoc_insertion_point(field_mutable:Backage.ForeignEntryDecl.lib)
  return _s;
}
inline const std::string& ForeignEntryDecl::_internal_lib() const {
  return _impl_.lib_.Get();
}
inline void ForeignEntryDecl::_internal_set_lib(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lib_.Set(value, GetArenaForAllocation());
}
inline std::string* ForeignEntryDecl::_internal_mutable_lib() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.lib_.Mutable(GetArenaForAllocation());
}
inline std::string* ForeignEntryDecl::release_lib() {
  // @@protoc_insertion_point(field_release:Backage.ForeignEntryDecl.lib)
  if (!_internal_has_lib()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.lib_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lib_.IsDefault()) {
    _impl_.lib_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ForeignEntryDecl::set_allocated_lib(std::string* lib) {
  if (lib != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lib_.SetAllocated(lib, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lib_.IsDefault()) {
    _impl_.lib_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.ForeignEntryDecl.lib)
}

// optional bytes alias = 7;
inline bool ForeignEntryDecl::_internal_has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ForeignEntryDecl::has_alias() const {
  return _internal_has_alias();
}
inline void ForeignEntryDecl::clear_alias() {
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ForeignEntryDecl::alias() const {
  // @@protoc_insertion_point(field_get:Backage.ForeignEntryDecl.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForeignEntryDecl::set_alias(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.alias_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Backage.ForeignEntryDecl.alias)
}
inline std::string* ForeignEntryDecl::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:Backage.ForeignEntryDecl.alias)
  return _s;
}
inline const std::string& ForeignEntryDecl::_internal_alias() const {
  return _impl_.alias_.Get();
}
inline void ForeignEntryDecl::_internal_set_alias(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.alias_.Set(value, GetArenaForAllocation());
}
inline std::string* ForeignEntryDecl::_internal_mutable_alias() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.alias_.Mutable(GetArenaForAllocation());
}
inline std::string* ForeignEntryDecl::release_alias() {
  // @@protoc_insertion_point(field_release:Backage.ForeignEntryDecl.alias)
  if (!_internal_has_alias()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.alias_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ForeignEntryDecl::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.alias_.SetAllocated(alias, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Backage.ForeignEntryDecl.alias)
}

// -------------------------------------------------------------------

// LineNumber

// uint32 line = 1;
inline void LineNumber::clear_line() {
  _impl_.line_ = 0u;
}
inline uint32_t LineNumber::_internal_line() const {
  return _impl_.line_;
}
inline uint32_t LineNumber::line() const {
  // @@protoc_insertion_point(field_get:Backage.LineNumber.line)
  return _internal_line();
}
inline void LineNumber::_internal_set_line(uint32_t value) {
  
  _impl_.line_ = value;
}
inline void LineNumber::set_line(uint32_t value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:Backage.LineNumber.line)
}

// uint32 offset = 2;
inline void LineNumber::clear_offset() {
  _impl_.offset_ = 0u;
}
inline uint32_t LineNumber::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t LineNumber::offset() const {
  // @@protoc_insertion_point(field_get:Backage.LineNumber.offset)
  return _internal_offset();
}
inline void LineNumber::_internal_set_offset(uint32_t value) {
  
  _impl_.offset_ = value;
}
inline void LineNumber::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Backage.LineNumber.offset)
}

// -------------------------------------------------------------------

// ExceptionEntry

// uint32 offset = 1;
inline void ExceptionEntry::clear_offset() {
  _impl_.offset_ = 0u;
}
inline uint32_t ExceptionEntry::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t ExceptionEntry::offset() const {
  // @@protoc_insertion_point(field_get:Backage.ExceptionEntry.offset)
  return _internal_offset();
}
inline void ExceptionEntry::_internal_set_offset(uint32_t value) {
  
  _impl_.offset_ = value;
}
inline void ExceptionEntry::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Backage.ExceptionEntry.offset)
}

// uint32 length = 2;
inline void ExceptionEntry::clear_length() {
  _impl_.length_ = 0u;
}
inline uint32_t ExceptionEntry::_internal_length() const {
  return _impl_.length_;
}
inline uint32_t ExceptionEntry::length() const {
  // @@protoc_insertion_point(field_get:Backage.ExceptionEntry.length)
  return _internal_length();
}
inline void ExceptionEntry::_internal_set_length(uint32_t value) {
  
  _impl_.length_ = value;
}
inline void ExceptionEntry::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:Backage.ExceptionEntry.length)
}

// uint32 target = 3;
inline void ExceptionEntry::clear_target() {
  _impl_.target_ = 0u;
}
inline uint32_t ExceptionEntry::_internal_target() const {
  return _impl_.target_;
}
inline uint32_t ExceptionEntry::target() const {
  // @@protoc_insertion_point(field_get:Backage.ExceptionEntry.target)
  return _internal_target();
}
inline void ExceptionEntry::_internal_set_target(uint32_t value) {
  
  _impl_.target_ = value;
}
inline void ExceptionEntry::set_target(uint32_t value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:Backage.ExceptionEntry.target)
}

// uint32 typeToken = 4;
inline void ExceptionEntry::clear_typetoken() {
  _impl_.typetoken_ = 0u;
}
inline uint32_t ExceptionEntry::_internal_typetoken() const {
  return _impl_.typetoken_;
}
inline uint32_t ExceptionEntry::typetoken() const {
  // @@protoc_insertion_point(field_get:Backage.ExceptionEntry.typeToken)
  return _internal_typetoken();
}
inline void ExceptionEntry::_internal_set_typetoken(uint32_t value) {
  
  _impl_.typetoken_ = value;
}
inline void ExceptionEntry::set_typetoken(uint32_t value) {
  _internal_set_typetoken(value);
  // @@protoc_insertion_point(field_set:Backage.ExceptionEntry.typeToken)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Backage

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_backage_2eproto
